<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Makima777</title>
  
  <subtitle>Makima777の博客</subtitle>
  <link href="https://makima777.github.io/atom.xml" rel="self"/>
  
  <link href="https://makima777.github.io/"/>
  <updated>2023-04-18T13:17:58.395Z</updated>
  <id>https://makima777.github.io/</id>
  
  <author>
    <name>Makima777</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++primer-第一章&amp;第二章</title>
    <link href="https://makima777.github.io/posts/5728e4e2.html"/>
    <id>https://makima777.github.io/posts/5728e4e2.html</id>
    <published>2023-04-16T12:32:31.000Z</published>
    <updated>2023-04-18T13:17:58.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章——开始">第一章——开始</h2><h3 id="编译、运行程序">编译、运行程序</h3><h4 id="返回值">返回值</h4><p>访问main的返回值的方法依赖于系统，在UNIX和Windows系统中，执行完一个程序后，可以通过以下方法活得其返回值。</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">UNIX</button></li><li class="tab"><button type="button" data-href="#-2">cmd</button></li><li class="tab"><button type="button" data-href="#-3">powershell</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">%ERRORLEVEL%</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">echo</span>] <span class="variable">$</span>?</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>其中PowerShell的echo可有可无，如果程序返回值为0则显示为True，否则为False。</p><h3 id="初识输入输出">初识输入输出</h3><h4 id="输入输出运算符">输入输出运算符</h4><p>以<strong>输出运算符</strong>(<code>&lt;&lt;</code>)为例，&lt;&lt;运算符接受两个运算对象，左侧的运算对象必须是一个<code>ostream</code>对象，右侧的运算对象就是要打印的值，此运算符将给定的值写到ostream对象中，输出运算符的结果就是其左侧运算对象，即该运算符的返回值为左侧的运算对象，所以以下两条语句等价</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">(std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="读取数量不定的输入数据">读取数量不定的输入数据</h4><p>当我们使用一个<code>istream</code>对象作为条件时，其效果就是检测流的状态。如果遇到文件结束符(<code>end-of-file</code>)，或遇到一个无效的输入(读取类型不匹配)时，istream对象的状态就会变为无效，出于无效状态的istream对象会使条件为假。</p><h4 id="缓冲区">缓冲区</h4><p>默认情况下，读<code>cin</code>会刷新<code>cout</code>；程序非正常终止时也会刷新<code>cout</code>。</p><h4 id="Cerr">Cerr</h4><p>一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到cerr的数据是不缓冲的。</p><h4 id="Clog">Clog</h4><p>一个ostream对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。</p><h2 id="变量与基本类型">变量与基本类型</h2><h3 id="基本内置类型">基本内置类型</h3><p>C++定义了一套包括<strong>算术类型</strong>(<code>arithmetic type</code>)和<strong>空类型</strong>(<code>void</code>)在内的基本数据类型，其中算数类型包含了字符、整型数、布尔值和浮点数。</p><h4 id="字符型">字符型</h4><p>字符型被分为了三种<code>char</code>、<code>signed char</code>、<code>unsigned char</code>，但是尽管字符型有三种，字符的表现形式只有两种：带符号的不带符号的。类型char实际上会表现为上述的其中一种，具体是哪种由编译器决定。</p><h4 id="类型转换">类型转换</h4><ul><li><p>将浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中小数点前的部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3.9999</span>; <span class="comment">// val = 3</span></span><br></pre></td></tr></table></figure></li><li><p>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示的数值总数取模后的余数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> val = <span class="number">-1</span>; <span class="comment">// val = 255</span></span><br></pre></td></tr></table></figure></li><li><p>赋给带符号类型一个超出它表示范围的值时，结果是<strong>未定义</strong>(<code>undefined</code>)的。</p></li><li><p>如果表达式里既有带符号类型又有无符号类型，那么带符号类型会自动转换成无符号类型。</p></li></ul><h4 id="字面值常量">字面值常量</h4><h5 id="整型和浮点型字面值">整型和浮点型字面值</h5><ul><li><p>以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="comment">/*十进制*/</span>    <span class="number">024</span><span class="comment">/*八进制*/</span>    <span class="number">0x14</span><span class="comment">/*十六进制*/</span></span><br></pre></td></tr></table></figure></li><li><p>默认情况下，十进制字面值是带符号数，八进制和十六进制可能是带符号的也可能是不带符号的。类型会从能容纳其数值的最小尺寸者([unsigned] int, long, long long)，short类型没有其字面值。</p></li><li><p>默认的，浮点型字面值是一个double。</p></li></ul><h5 id="转义序列">转义序列</h5><h6 id="关于问号">关于问号</h6><p>问号也在转义序列中，主要是为了防止 <strong><a href="https://zh.cppreference.com/w/cpp/language/escape">三标符</a></strong> (<code>trigraph</code>），会在辨识注释和字面量之前被分析，如<code>??&lt;</code>会被编译成<code>&#123;</code>，不过三标符在<code>c++17</code>中已经被移除也就不需要转义了。(平常普通使用也不需要)</p><h6 id="泛化的转义序列">泛化的转义序列</h6><p>其形式是<code>\x</code>后紧跟一个或多个十六进制数字，或者<code>\</code>后紧跟1-3个八进制数字。</p><p>如果反斜线后跟着的八进制数字超过3个，只有前3个数字构成转义序列。</p><p>相反，<code>\x</code>会用到后面跟着的所有数字，超过范围会报错。</p><h5 id="指定字面值的类型">指定字面值的类型</h5><h6 id="字符和字符串字面值">字符和字符串字面值</h6><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">含义</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">Unicode16字符</td><td style="text-align:center">char16_t</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">Unicode32字符</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">宽字符</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center">u8</td><td style="text-align:center">UTF-8(仅用于字符串字面常量)</td><td style="text-align:center">char</td></tr></tbody></table><h6 id="整型字面值">整型字面值</h6><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">u or U</td><td style="text-align:center">unsigned</td></tr><tr><td style="text-align:center">l or L</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">ll or LL</td><td style="text-align:center">long long</td></tr></tbody></table><h6 id="浮点型字面值">浮点型字面值</h6><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">f or F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">l or L</td><td style="text-align:center">long double</td></tr></tbody></table><p>注意对于整型字面值，是规定其最小的匹配值，例如以<code>UL</code>为后缀的数据类型将根据具体数值或者取<code>unsigned long</code>，或者取<code>unsigned long long</code>。</p><h3 id="变量">变量</h3><h4 id="变量定义">变量定义</h4><h5 id="初始值">初始值</h5><blockquote><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值替代。</p></blockquote><h5 id="列表初始化">列表初始化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> val = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> val&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>后两种初始化的形式被称为<strong>列表初始化</strong>(<code>list initialization</code>)，当用于内置类型的变量时，这种形式有一个重要特点:<code>如果我们使用列表初始化存在丢失信息的风险，则编译器将报错</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> val&#123;pi&#125;;</span><br><span class="line"><span class="comment">// Type &#x27;float&#x27; cannot be narrowed to &#x27;int&#x27; in initializer list (fix available)</span></span><br></pre></td></tr></table></figure><h5 id="默认初始化">默认初始化</h5><p>定义于函数体内的内置数据类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值由类确定。</p><h4 id="变量声明和定义的关系">变量声明和定义的关系</h4><p><strong>声明</strong>(<code>declaration</code>)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>(<code>definition</code>)负责创建与名字相关联的实体。</p><p>变量声明规定了变量的类型和名字，在这一点上和定义相同，但定义还申请储存空间，也可能会为变量赋一个初值。</p><p>想声明一个变量而非定义，就在变量名前添加关键字<code>extern</code>，而且不要显示地初始化变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明i而非定义i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">//声明并定义j</span></span><br></pre></td></tr></table></figure><p><code>任何包含了显式初始化的声明即成为定义。</code>extern语句包含初始值就不再是声明而是定义，抵消掉了extern的作用。</p><blockquote><p>变量能且只能被定义一次，但是可以被多次声明。</p></blockquote><h3 id="复合类型">复合类型</h3><h4 id="引用-左值引用">引用(左值引用)</h4><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。</p></blockquote><p>获取引用的值，实际上是获取了与引用绑定的对象的值。</p><h4 id="指针">指针</h4><p>指针与引用的不同点：</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向及规格不同的对象。</li><li>指针无须在定义时赋初值。</li></ol><blockquote><p>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p></blockquote><blockquote><p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p></blockquote><h3 id="const限定符">const限定符</h3><h4 id="const的引用">const的引用</h4><p><code>常量引用</code>实际上是<code>对const的引用</code>的简称。</p><h5 id="初始化和对const的引用">初始化和对const的引用</h5><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外，其中一个就是在初始化常量引用的时候允许使用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象，字面值，甚至是个一般表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>当一个常量引用被绑定到另外一种类型时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure><p>为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> temp = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure><p>在这种情况下，ri绑定了一个<strong>临时量</strong>(<code>temporary</code>)，临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象，上述r3也会进行这样的转换。(r2说不定也是，只是没法验证)</p><h5 id="对const的引用可能引用一个非const的对象">对const的引用可能引用一个非const的对象</h5><blockquote><p>常量引用仅仅对引用可参与的操作作出了限定，对于引用的对象本身是否是一个常量未作限定，允许通过其他方式改变对象的值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;</span><br><span class="line">r2 = <span class="number">0</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>当通过r1修改i的值之后，r2的值实际上也变成了0；</p><h4 id="指针和const">指针和const</h4><h5 id="指向常量的指针">指向常量的指针</h5><p>类似常量引用，<strong>指向常量的指针</strong>(<code>pointer to const</code>)不能用于修改所指对象的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;</span><br></pre></td></tr></table></figure><p>指针类型必须与其所指对象的类型一致，但是有两个例外，其中一个就是允许一个指向常量的指针指向一个非常量的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval;</span><br></pre></td></tr></table></figure><blockquote><p>与常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，对象本身可以通过其他方式改变。</p></blockquote><h5 id="const指针">const指针</h5><p><strong>常量指针</strong>(<code>const pointer</code>)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针的地址)就不能改变了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumber = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumber;</span><br></pre></td></tr></table></figure><p>弄清这些声明的含义最有效的方法就是从右向左读。</p><h4 id="顶层const">顶层const</h4><p>用名词<strong>顶层const</strong>(<code>top-level const</code>)表示指针本身是个常量，用名词<strong>底层const</strong>(<code>low-level const</code>)表示指针所指的对象是一个常量。</p><p>执行拷贝操作的时候，顶层const不受影响。但是底层const的限制不能忽视，拷入和拷出的对象必须具有相同的底层const资格或者两个对象的数据类型能够转换，一般来说非常量能够转换成常量。</p><h4 id="constexpr和常量表达式">constexpr和常量表达式</h4><p><strong>常量表达式</strong>(<code>const expression</code>)是指值不会改变并且在编译过程就能得到计算结果的表达式。</p><blockquote><p>一个对象(或表达式)是否是常量表达式由它的数据类型和初始值共同决定。</p></blockquote><h5 id="constexpr变量">constexpr变量</h5><p>C++11规定允许将变量声明为<strong>constexpr</strong>类型以便编译器来验证变量的值是否是一个常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">// 只有size是一个constexpr函数时正确</span></span><br></pre></td></tr></table></figure><h5 id="字面值类型">字面值类型</h5><p>常量表达式的值在编译时就得到计算，所以用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就将它们称为“字面值类型”(literal type)。</p><p>目前，算术类型、引用和指针都属于字面值类型。</p><p>尽管指针和引用能够定义为constexpr，但他们的初始值受到严格限制。<code>一个constexpr指针的初始值必须是nullptr或者0，或者是储存于某个固定地址的对象</code>(全局或者static，引用限制为后者)。</p><h5 id="指针和constexpr">指针和constexpr</h5><blockquote><p>在constexpr声明中定义一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。(顶层const)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// 指向整数常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// 指向整数的常量指针</span></span><br></pre></td></tr></table></figure><h3 id="处理类型">处理类型</h3><h4 id="类型别名-type-alias">类型别名(type alias)</h4><h5 id="typedef">typedef</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure><h5 id="别名声明-alias-declaration">别名声明(alias declaration)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> myint = <span class="type">int</span> *;<span class="comment">// myint是int*的同义词</span></span><br></pre></td></tr></table></figure><h5 id="指针、常量和类型别名">指针、常量和类型别名</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">// cstr是一个指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps;<span class="comment">// ps是一个指针，它的对象是指向char的常量指针</span></span><br></pre></td></tr></table></figure><p>const是对给定类型的修饰，声明语句中用到pstring时，<code>其基本类型是指针</code>。</p><h4 id="auto类型说明符">auto类型说明符</h4><p>auto让编译器通过初始值来推算变量的类型，所以显然，auto定义的类型必须要有初始值。</p><p>因为一条声明语句只能有一个基本数据类型，所以该语句的所有变量的初始值类型都必须一样。</p><h5 id="复合类型、常量和auto">复合类型、常量和auto</h5><blockquote><p>引用作为初始值时，真正参与初始化的是引用对象的值，所以编译器会使用引用对象的类型作为auto的类型，而不是引用。</p></blockquote><blockquote><p>auto一般会忽略掉顶层const，同时底层const则会保留下来。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> a = ci;</span><br><span class="line"><span class="keyword">auto</span> b = cr;<span class="comment">// 都是整数</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;i;<span class="comment">// 整型指针</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;ci;<span class="comment">// 指向整数常量的指针(对常量对象取地址是一种底层const)</span></span><br></pre></td></tr></table></figure><p>可以明确指出顶层const</p><blockquote><p>设置一个类型为auto的引用时，初始值的顶层常量属性保留</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;e = ci;<span class="comment">// 整型常量引用</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;f = <span class="number">42</span>;<span class="comment">// 为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符">decltype类型指示符</h4><blockquote><p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">// const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = <span class="number">0</span>;<span class="comment">// const int &amp;</span></span><br></pre></td></tr></table></figure><h5 id="decltype和引用">decltype和引用</h5><p>decltype使用的表达式不是一个变量，则返回表达式对应的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;<span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给该对象赋值。</p></blockquote><blockquote><p>如果给变量加上了一层或多层括号，编译器就会把它当作一个表达式，变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype会得到引用类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// 错误，int&amp;,引用需要初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;<span class="comment">// int</span></span><br></pre></td></tr></table></figure><h3 id="自定义数据结构">自定义数据结构</h3><p>C++11规定，可以为数据成员提供一个类内初始值，<code>不能使用圆括号</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val1 = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> val2 = &#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="type">int</span> val3&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>预处理变量无视C++关于作用域的规则(即使在函数中定义并且没调用，后续(物理后续即后面行的)的代码也依然视其已定义)</p></blockquote>]]></content>
    
    
    <summary type="html">C++ Primer第一章和第二章阅读笔记</summary>
    
    
    
    <category term="Cpp Primer" scheme="https://makima777.github.io/categories/Cpp-Primer/"/>
    
    
    <category term="Cpp" scheme="https://makima777.github.io/tags/Cpp/"/>
    
    <category term="阅读笔记" scheme="https://makima777.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>markdown加粗失效</title>
    <link href="https://makima777.github.io/posts/885d662c.html"/>
    <id>https://makima777.github.io/posts/885d662c.html</id>
    <published>2023-04-13T13:32:15.000Z</published>
    <updated>2023-04-13T14:58:07.286Z</updated>
    
    <content type="html"><![CDATA[<p>今天用markdown给链接加粗的时候出现了在Typora能正常显示，但是上传到博客就不能正常显示的问题，于是去查找了相关问题，现总结和记录一下。</p><p>markdown用*或者_给内容进行斜体或者加粗的操作，不过需要注意的是并不是可以随意加的，其实markdown是有<a href="https://spec.commonmark.org/0.30/#right-flanking-delimiter-run">规定</a>的。</p><p>简单来说就是*和_被分为左侧定界符序列和右侧定界符序列，判断如下</p><h4 id="左侧定界符序列">左侧定界符序列</h4><ul><li>后面不能是空白</li><li>前面没有空白或者标点符号的时候，后面不能是标点符号</li></ul><h4 id="右侧定界符序列">右侧定界符序列</h4><ul><li>前面不能是空白</li><li>后面没有空白或者标点符号的时候，前面不能是标点符号</li></ul><p>当**是左侧定界符序列的时候表示开始粗体，相对的右侧定界符序列表示结束粗体。</p><p>于是就可以发现问题所在了</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">错误示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla<span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span>blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla**<a href="www.example.com">示例</a>**blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>两侧定界符序列都不满足条件，所以需要在左侧前加右侧后各加一个空格。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正确示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla <span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span> blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla <strong><a href="www.example.com">示例</a></strong> blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>但这样会导致渲染之后左右有多的空格，有一个解决方法就是使用零宽字符(<code>Zero Width Space</code>),实体名称<code>&amp;ZeroWidthSpace;</code>,Unicode为U+200B，这个字符不算做空白字符，空白字符是指<a href="https://www.compart.com/en/unicode/category/Zs#UNC_CAT">Zs</a>类的17个字符，所以可以这样更改</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正确示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla&amp;#x200B;<span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span>&amp;#x200B;blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla​<strong><a href="www.example.com">示例</a></strong>​blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>讲道理的话，零宽字符加在左侧*后面右侧*前面应该也是可行的，毕竟他不算是标点字符，不过博客不能正常显示，可能是&amp;的问题，但直接复制放在那个位置的话倒是能在csdn上显示成功，github不太行，可能渲染方式不一样还是怎么回事。</p><h4 id="零宽字符其他用途">零宽字符其他用途</h4><h5 id="换行">换行</h5><p>当一行过长的时候荧幕宽度不足以单行显示时，可以使用它来指定换行位置。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正常显示</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>LongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">加入零宽字符</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongLongLongLongLongLongLongLong&amp;#x200B;BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>LongLongLongLongLongLongLongLong​BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h5 id="绕过敏感词检查和创造不可复制的伪链接等">绕过敏感词检查和创造不可复制的伪链接等</h5><h4 id="参考">参考</h4><p><a href="https://juejin.cn/post/7064565848421171213">为什么掘金的 Markdown 加粗语法（**……**）有时候不生效？</a></p><p><a href="https://symbl.cc/cn/">SYMBL (◕‿◕)</a></p><p><a href="https://www.compart.com/en/unicode/">Unicode - Compart</a></p>]]></content>
    
    
    <summary type="html">记录并解决markdown加粗语法问题</summary>
    
    
    
    <category term="markdown" scheme="https://makima777.github.io/categories/markdown/"/>
    
    
    <category term="markdown" scheme="https://makima777.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>[BUAA OO Unit 2 HW8] 第二单元总结</title>
    <link href="https://makima777.github.io/posts/8f38982b.html"/>
    <id>https://makima777.github.io/posts/8f38982b.html</id>
    <published>2023-04-12T03:46:39.000Z</published>
    <updated>2023-04-13T13:22:08.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>第二单元的主题是电梯调度问题，主要是初步学习多线程的编程思想，解决线程交互和线程安全的问题。早就听说第二单元多线程是OO的一座大山，荣文戈老师也说过以后上班遇到的程序基本上全都和多线程挂钩，所以多线程的学习是很关键的，给哪个对象加锁，如何正确且高效地给对象加锁，都是值得思考的问题。</p><p>这一单元的三次作业也是层层递进，逐步实现了电梯维修、加入电梯、限制电梯可达性和限制楼层服务电梯数量等功能。在本次作业中，我也学会了一些比较常用的设计模式如<code>单例模式</code>和<code>观察者模式</code>等，以及经典的并发同步模式<code>生产者-消费者模式</code>，使得整个项目的耦合度更低，代码层次清晰。</p><h2 id="第一次作业">第一次作业</h2><p>第一次作业为模拟多线程实时电梯系统，实现6部电梯对实时加入的乘客请求做出反应，接到乘客并送到指定位置，需要模拟电梯的上下行、开关门以及乘客的进出。</p><h3 id="架构">架构</h3><h4 id="Producer-Consumer模型">Producer-Consumer模型</h4><p>首先分析需要将哪些类作为线程运行，首先就是<strong>输入</strong>（<code>InputHandler</code>)需要不断读取请求，其次就是<strong>电梯</strong>(<code>Elevator</code>)需要不断反应请求并模拟运行。</p><p>而将这两个线程连接起来的就是<strong>请求</strong>(<code>Request</code>)，所以生产者-消费者模型的结构也很清晰了，<strong>输入</strong>作为生产者，<strong>电梯</strong>作为消费者，在两个之间我们需要一个容器来盛放<strong>请求</strong>，于是设计<strong>请求队列</strong>(<code>RequestTable</code>)作为这个容器，容器有放入请求和取出请求的功能，而之所以容器不作为线程就在于放入和请求这两个动作的发出者不是容器本身(<s>参考自助餐窗口，柜台是固定的</s>)。</p><p>至此，我们可以得到以下的结构</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122000.png" alt="image-20230412192000478"></p><p>我采用的是所有电梯共用一个<strong>请求队列</strong>的做法，各个电梯自由竞争。</p><h4 id="调度策略">调度策略</h4><p>电梯调度问题没有一个全局最优解，总会有一些情况使得一个算法劣于其他的算法。目前有的与电梯调度调度相关的算法有<code>ALS</code>,<code>LOOK</code>,<code>SCAN</code>等，课程组给出的算法是<code>ALS</code>，但往届学长大多选择的是<code>LOOK</code>算法，并且我也感觉后者实现的难度要相对低一点，所以选择了<code>LOOK</code>算法。</p><p>具体实现过程——</p><ul><li>首先电梯有一个初始的运动方向(建议使用$\pm1$，实现比booolean类型方便)</li><li>判断是否需要开门<ol><li>电梯内是否有人出电梯</li><li>该楼层是否有人的请求方向和电梯的运动方向一致</li></ol></li><li>判断电梯内是否有人<ul><li>如果有人，那么沿当前方向继续移动一层</li><li>否则，判断请求队列是否为空<ul><li>如果不为空，接着判断当前方向是否有请求<ul><li>如果有请求，那么沿当前方向继续移动一层</li><li>否则，变换方向</li></ul></li><li>否则，判断输入线程是否结束<ul><li>如果结束了，那么结束电梯线程</li><li>否则，进入等待状态</li></ul></li></ul></li></ul></li></ul><p>如上所述，电梯做出的反应有<code>Open</code>，<code>Move</code>，<code>Reverse</code>，<code>Wait</code>，<code>Over</code>5种，可以设计一个<strong>策略类</strong>(<code>strategy</code>)来封装<code>LOOK</code>算法，根据电梯目前的状态给出电梯需要做出的反应，电梯收到后进行相应的动作。这样可以使得电梯运行和判断相分离，电梯本身更加专注于动作，结构层次也更加清晰。</p><h4 id="类图和时序图">类图和时序图</h4><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304121753.png" alt="image-20230412211753149"></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304132843.png" alt="image-20230413112843704"></p><p>大致流程如上图所示，无论是放入请求还是输入结束，都会使得<strong>请求队列</strong>唤醒<strong>电梯</strong>，而电梯都会根据<strong>策略</strong>来进行下一步动作。</p><h3 id="锁和同步">锁和同步</h3><p>本次作业采用的是使用<code>synchronized</code>取得对象锁，避免线程安全问题，保证同一时间不会出现两个线程对同一对象写或者读写。</p><p><code>synchronized</code>有三种加锁的方式——</p><ol><li><p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法：作用于当前类的所有实例，进入同步代码前要获得<strong>当前类的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰一个代码块：给指定的类或者对象加锁，在进入同步代码前需要获得指定类或者对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj or example.class)&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>修饰实例方法与在方法内修饰整个代码块取得当前实例的锁类似，而修饰静态方法与在方法内修饰整个代码块取得当前类的锁类似。</p><p>需要注意的是实例的锁与类的锁不同，实例的锁属于这个实例，类的锁属于类(<s>废话</s>)。讲这个的目的就是为了说明，当一个线程访问加锁的静态方法时，另一个进程依然可以访问加锁的实例方法，两者不冲突。当然加锁的方法和不加锁的方法也不会冲突。</p><p>需要加锁的位置就是有多个线程进行读写的共享数据，在本次作业种显然是<strong>请求队列</strong>，有<strong>输入</strong>的写，以及<strong>电梯</strong>的读写，为了保证每次操作的正确性，我们在进行读写之前都要对<strong>请求队列</strong>加锁，保证进行的是原子操作(执行过程不会被打断)。本次作业将<strong>请求队列</strong>内部涉及修改和读取修改变量的方法都加了锁，在外部对需要保证<strong>请求队列</strong>状态的代码块上了锁。</p><p><code>notifyAll</code>的操作只在修改了共享变量之后存在。</p><h3 id="复杂度分析">复杂度分析</h3><p>部分方法复杂度如下<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304121904.png" alt="image-20230412211904780"></p><p>主要出在<strong>策略</strong>类中，因为涉及大量的if-else判断以及for循环遍历楼层的请求队列，所以这部分复杂度略高。</p><h3 id="tips">tips</h3><h4 id="二次询问">二次询问</h4><p>因为各个电梯共用一个请求队列，并且策略类将询问和执行分开了，所以可能会出现多个电梯在同一个楼层都给出开门的指示，但是显然只有一个电梯会接到人(接人操作上锁，所以不会出现接到同一个人)，其他的电梯就只开门和关门，这样会白白增加耗电量(<s>虽然自由竞争本身会出现多个电梯都向一个请求跑，耗电量巨大</s>)。一种解决方法就是在开门的操作内部，先对请求队列上锁，然后再次询问策略类当前动作是否还应该是开门，如果是才将人取出，进行接下来的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (requestTable) &#123;</span><br><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> scheduler.getAdvice(curFloor,curNum,direction,eleMap.get(curFloor));</span><br><span class="line"><span class="keyword">if</span> (advice != Advice.OPEN) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmpQueue = requestTable.take(curFloor,direction,curNum - curQueue.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电梯反转">电梯反转</h4><p>在电梯没人判断当前方向上是否有人的时候，不应该包含当前楼层，否则电梯直接沿着当前方向走了，会出现升天或者遁地的情况。</p><h4 id="开门判断">开门判断</h4><p>为了简便，在策略内判断是否有人进入的时候，传入的当前楼层人数包括可能下电梯的人，所以可能因为超载判断为不需要开门，不过没关系，因为如果有人回下电梯的话就一定会开门，在取人的时候减去下去的人数即可。(<s>要是没有二次询问这个操作的话，直接按顺序下人上人不用特意减，可惜删不得</s>)</p><h4 id="HashMap遍历删除">HashMap遍历删除</h4><p>在从请求队列中取人的时候我使用了如下操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (PersonRequest person : curQueue) &#123;</span><br><span class="line"><span class="keyword">if</span> (curNum + tmpQueue.size() == Tool.capacity) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((person.getToFloor() - curFloor) * direction &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">tmpQueue.add(person);</span><br><span class="line">curQueue.remove(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即一边遍历一边删除，但是运行的时候会出现<code>java.util.ConcurrentModificationException</code>的报错，于是去网上查找了相关资料。</p><p>简单来说就是HashMap内部维护了一个modCount变量，迭代器里维护了一个expectedModCount变量，初始两者相同，每次HashMap移除和新加元素的时候modCount会自增，此时迭代器里的expectedModCount不变，而迭代器遍历的时候会用到nextNode()方法，当两个值不等的时候就会抛出异常。</p><p>基本上JAVA集合类在遍历时不用迭代器进行删除都会报错，这样是为了防止高并发情况下，多个线程同时修改集合导致数据不一致。</p><p>解决方法就是使用迭代器进行遍历和删除，迭代器的删除也会先判断两者值是否相等，然后调用HashMap的removeNode()方法，最后会令<code>expectedModCount=modCount</code>，这样就不会出现错误了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;PersonRequest&gt; it = curQueue.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext() &amp;&amp; curNum + tmpQueue.size() &lt; Tool.capacity) &#123;</span><br><span class="line"><span class="type">PersonRequest</span> <span class="variable">person</span> <span class="operator">=</span> it.next();</span><br><span class="line"><span class="keyword">if</span> ((person.getToFloor() - curFloor) * direction &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">tmpQueue.add(person);</span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用线程安全的currentHashMap替代HashMap，或者在遍历结束后再遍历取出来的列表对请求队列进行删除。</p><h4 id="些许优化">些许优化</h4><p>在研讨课时，有同学提出既然自由竞争会出现1个请求唤醒6部电梯的情况，那么每来一个请求不使用notifyAll而是使用notify就可以减少耗电量，我觉得有道理，不过貌似这样就不像自由竞争了，虽然也和直接分配不同，总的来说还是一个不错的提议。</p><p>其次就是另一个同学提出在电梯取人的时候可以不直接锁整个队列，而是将对应楼层的队列锁住，这样其他楼层的电梯也可以在此时取人，虽然优化可能不是很明显，不过想法很好，显然要是为了正确性锁住整个队列是更好的，比较无脑，为了性能的话就要将需要锁的部分想清楚，不然正确性可能没法保证。</p><h3 id="Bug分析">Bug分析</h3><p>中测中出现上述有关HashMap删除的错误，强测和互测没有出现Bug，强测得分97.1553，还是比较出乎我的意料，毕竟自由竞争耗电量确实难蚌。</p><h2 id="第二次作业">第二次作业</h2><p>第二次作业在第一次作业的基础上需要模拟电梯系统扩建和日常维护时乘客的调度，同时电梯增加速度和容量参数。</p><h3 id="架构-2">架构</h3><h4 id="调度器">调度器</h4><p>为了实现扩建和维护功能就需要一个统领所有电梯的容器，来记录目前还在运行的电梯，于是设计了<strong>调度器</strong>(<code>Scheduler</code>)，同时由于第一次作业6部电梯一起抢一个请求实在让我挺难受的，所以我决定让<strong>调度器</strong>同时担任分发请求的任务，让每部电梯都有自己的<strong>乘客队列</strong>，于是产生了以下结构<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304131949.png" alt="image-20230413101941994"></p><p>相比于第一次作业，<strong>输入</strong>得到请求有三种分别是<code>PersonRequest</code>、<code>ElevatorRequest</code>、<code>MaintainRequest</code>，不同的请求处理方式肯定事不同的，于是在哪个部分对请求进行分类就是一个问题，我采用的方式是在<strong>调度器</strong>内进行分类处理，于是<strong>输入</strong>和<strong>请求队列</strong>基本上就不需要改动，然后<strong>电梯</strong>依赖的<strong>请求队列</strong>变成了<strong>乘客队列</strong>也只是相当于换了个名字，总的来说原则就是让每个类的职责清晰明了。</p><h4 id="换乘-线程结束">换乘 + 线程结束</h4><p>因为维修请求的存在，电梯可能放出没有到达目的地的乘客，所以会出现乘客需要换乘的情况，处理还是比较简单，直接将没有到达目的地的乘客更改出发楼层然后重新丢进<strong>请求队列</strong>即可，<strong>调度器</strong>会将其作为一个新的请求读取并分配。</p><p>但是随之而来就出现了另一个问题，电梯线程在何时结束，之前的结束判断是电梯内没人并且<strong>请求队列</strong>为空且输入结束，但是在本次作业请求来源不再只是<strong>输入</strong>，还可能是换乘的乘客，所以需要改变结束判断。</p><p>可以发现，虽然有换乘但是总的乘客数是不变的，于是可以设计<strong>请求计数</strong>(<code>RequestCount</code>)维护一个count，当<strong>输入</strong>向<strong>请求队列</strong>放入乘客的时候令count+1，当电梯将乘客送到目的地之后令count-1，于是结束判断就变成了输入结束且count=0。</p><p>由于JAVA没有全局变量这个概念，所以可以使用 <strong><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a></strong> 实现全局变量，本次作业<strong>请求队列</strong>和<strong>请求计数</strong>都使用了单例模式(静态变量和方法实现在本次作业也可以，不过两者略有区别，在此不做讨论)。</p><p>有一点需要吐槽的是，课程组给出的<code>PersonRequest</code>不支持修改出发楼层，于是我自己写了一个<code>Person</code>，没什么不同只是为了修改，当然重新实例化一个<code>PersonRequest</code>也是可行的。(<s>不过这个名字有点长，我不是很喜欢</s>)</p><h4 id="类图和时序图-2">类图和时序图</h4><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304131324.png" alt="image-20230413111324473"></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304133541.png" alt="image-20230413113541430"></p><h3 id="复杂度分析-2">复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304133710.png" alt="image-20230413113710867"></p><p><strong>调度器</strong>的run内部根据<strong>请求队列</strong>的状态判断是结束线程还是等待还是处理请求，if-else语句导致复杂度较高。</p><h3 id="tips-2">tips</h3><ul><li>本次作业中每个电梯都有自己的乘客队列，所以不再需要二次询问。</li><li>理论课上讲解了读写锁的使用，能够允许多个线程同时进行读，不过现在jdk版本下synchronized效率也挺高的，也就没进行更改。</li><li>这次作业要采用自由竞争也是可以的，由输入对请求分类然后进行操作即可，不过架构不是很好看就是了，提这个的目的只是觉得我的调度没有用到速度这一参数，自由竞争在这方面还是有一定优势。</li><li>在接到维修指令之后需要立即将电梯从调度器中删除，防止有新的请求放入其中。</li></ul><h3 id="Bug分析-2">Bug分析</h3><p>中测的时候出现了以下bug</p><ul><li><strong>调度器</strong>在<strong>请求队列</strong>中wait，<strong>请求计数</strong>不能直接唤醒，需要先获得<strong>请求队列</strong>的锁(我感觉这一部分我写的比较混乱)</li><li>因为我自己写了<code>Person</code>，但是<strong>调度器</strong>在处理的时候忘记判断了，导致换乘的乘客没有处理，虽然我加了<code>assert</code>，但是运行的时候没加-ea参数，导致没及时发现错误。(<s>值得一提的是课程组貌似也没有这个参数，所以找错还挺麻烦的，不过这是一个好习惯</s>)</li></ul><p>强测没有问题得分95.1183，互测出现了程序无法结束的问题，我找了很久也不知道问题出现在哪。</p><p>分配策略我采用的是纯随机(random)，运气不好的话可能都分到一部电梯去了。</p><h2 id="第三次作业">第三次作业</h2><p>第三次作业在第二次作业的基础上，限制了电梯的可达性(只能在一些楼层开门服务)和楼层的最多服务电梯数。</p><h3 id="架构-3">架构</h3><p>这次作业的架构没有什么调整，增加的功能都可以放在已有的模块中进行实现，故UML类图和时序图可以参照第二次作业。</p><h3 id="功能实现">功能实现</h3><h4 id="可达性">可达性</h4><p>虽然规定了电梯只能在某些楼层开门服务，但在遇到维修的时候也是可以突破这个限制的，所以为了统一性我们不应该让可达性成为电梯的内置属性，而是通过<strong>调度器</strong>分配符合电梯可达性的乘客，让其看上去是满足要求的，实际上电梯都是功能完全的，能够在任意楼层开门。</p><p>那么问题就在<strong>调度器</strong>如何进行分配了，由于可达性的存在可能会出现乘客一趟不能到达目的地的情况，于是很自然的想到给乘客增加一个当前目的地的属性，对于这个属性的选取有很多种考量方法，我采用的和课程组类似——寻找最少换乘次数的策略，然后选择已有请求最少的电梯进行分配。</p><p>首先在<strong>调度器</strong>内维护一个二维数组map[i][j]表示有几部电梯能够从i楼到j楼，每次增加或者删除一个电梯就根据它的可达性对map进行更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateMap</span><span class="params">(<span class="type">int</span> access,<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Tool.minFloor;i &lt;= Tool.maxFloor;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (accessible(access,i)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Tool.minFloor; j &lt;= Tool.maxFloor;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (accessible(access,j)) &#123;</span><br><span class="line">map[i][j] += type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最少换乘次数dis[i][j]的计算可以简单的使用floyd即可，赋初值部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Tool.minFloor;i &lt;= Tool.maxFloor;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Tool.minFloor;j &lt;= Tool.maxFloor;j++) &#123;</span><br><span class="line">dis[i][j] = i == j ? <span class="number">0</span> : map[i][j] != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算完最短路关于选择目的地采用<code>map[from][i] != 0 &amp;&amp; dis[from][i] + dis[i][to] == dis[from][to]</code>判断即可，最后会返回一个可行的目的地，但是正规来讲的话应该返回一个集合，这样后续分配会更加均匀。</p><p>需要注意的是，设置当前目的地后电梯的策略类的判断同向也应该做出相应修改，其次每次请求被<strong>调度器</strong>取出时都会重新规划，而不是规划出总的路线，因为如果路线中的电梯被维修了就需要重新规划，为了简便就每次都算一次。</p><h4 id="楼层限制">楼层限制</h4><p>本次作业限制一层楼同时只有4个服务(开门)的电梯，2个只接人($set \sube new_set $)的电梯，后者属于前者，因为在我的实现中出去的乘客不会被马上接进来，所以只接人电梯相当于是没有出去的人。</p><h5 id="Semaphore">Semaphore</h5><p>实验课上介绍了<strong>Semaphore</strong>(信号量)的使用，锁的存在使得同一时间只有一个线程能够操作这个对象，而如果想要多个线程同时使用的话，就需要信号量了。信号量内部维护了一个计数器存着可以访问的共享资源的数量，线程要想访问共享资源就需要获得信号量，如果计数器大于0则允许访问并将计数器-1，如果计数器等于0则线程进入休眠，当某个线程释放信号量之后休眠的进程会被唤醒并尝试获取信号量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>,<span class="literal">true</span>); <span class="comment">// 信号量总数，是否公平(先到的先获得)</span></span><br><span class="line">semaphore.acquire(); <span class="comment">// 获取信号量</span></span><br><span class="line">semaphore.release(); <span class="comment">// 释放信号量</span></span><br></pre></td></tr></table></figure><p>获得信号量之后一定要释放。</p><h5 id="实现">实现</h5><p>有两种限制，所以对每层楼都需要两个信号量记为s1(4,true),s2(2,true)，当电梯需要开门的时候，如果是普通的电梯只需要获得s1即可，而只接人电梯则需要先获得s1再获得s2(顺序好像没关系)，关门的时候再释放相应信号量即可，信号量都放在了<strong>请求计数</strong>中。</p><h3 id="复杂度分析-3">复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304132246.png" alt="image-20230413172246586"></p><p>getDispatchGoal是求下一个目的地的部分，内部有挺多的循环嵌套和if-else判断。</p><h3 id="Bug分析-3">Bug分析</h3><p>三次测试都没问题，强测得分95.2392，不过用hhl同学的评测机总会是不是出现线程无法正常结束的情况，通过输出信息发现是有乘客被吃掉了，放入了电梯但是并没有去接他，最后也没有发现是哪出问题了。</p><h2 id="心得体会">心得体会</h2><ul><li><p>三次作业电梯运行、策略、输入以及请求队列部分原有的代码基本上都不会发生太大改变，主要的变化在于电梯增加维修的能力，调度器更换调度策略还有结束的判断等，不过只要大的框架定了后续的迭代也就比较简单了。可以发现的是后续迭代课程组对没有调度器的自由竞争并不是很友好，如果不在第二次作业进行重构的话，第三次作业需要改动的东西就更多了。不过架构的确定还是蛮看经验的，也不能说某一个架构就一定好，不过还是应该尽量满足<strong>solid</strong>原则。</p></li><li><p>性能方面，我还是为了简单和易于实现起见，牺牲了部分性能，调度采用自由竞争、随机分配和均匀分配，有的同学采用影子电梯(复制所有电梯状态，模拟判断请求的最优分配方式)，听说得分挺高的，不过本来电梯调度就没有全局最优，我认为首要的还是应该保证架构，有了比较好的架构，换一个调度器也不是很麻烦的事，就像荣文戈老师说的，分工好之后要是这个调度不行就换个程序员做调度器。</p></li><li><p>总的来说，相比于第一单元，这一单元感觉架构更加清晰，各个模块耦合度不高，功能也相对清晰，更有面向对象的感觉。不过这次作业还是留下了一点遗憾，就是第二三次作业的bug还是没找出来，这也让我感到多线程的艰难。</p></li></ul><h2 id="参考">参考</h2><p><a href="https://hyggge.github.io/2022/04/29/oo/oo-di-er-dan-yuan-zong-jie/">「BUAA-OO」第二单元:电梯调度 | Hyggge’s Blog</a></p><p><a href="https://www.cnblogs.com/saltyfishyjk/p/16218001.html#plantuml%E7%BB%98%E5%9B%BE">「BUAA OO Unit 2 HW8」第二单元总结 - 被水淹没的一条鱼</a></p><p><a href="https://blog.csdn.net/qq_41082953/article/details/120056344">HashMap遍历的时候使用map.remove会报错</a></p><p><a href="https://javastack.blog.csdn.net/article/details/129434123">为什么 HashMap 不能一边遍历一边删除？</a></p>]]></content>
    
    
    <summary type="html">总结OO课程第二单元电梯调度作业</summary>
    
    
    
    <category term="面向对象" scheme="https://makima777.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="BUAA" scheme="https://makima777.github.io/tags/BUAA/"/>
    
    <category term="JAVA" scheme="https://makima777.github.io/tags/JAVA/"/>
    
    <category term="电梯调度" scheme="https://makima777.github.io/tags/%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>nvim-配置</title>
    <link href="https://makima777.github.io/posts/1ce0a0b5.html"/>
    <id>https://makima777.github.io/posts/1ce0a0b5.html</id>
    <published>2023-04-11T14:11:38.000Z</published>
    <updated>2023-04-12T08:39:13.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在配置nvim插件的时候遇到了很多的问题，现在记录下来防止以后重复工作，整个配置放在了<a href="https://github.com/Makima777/nvim">Makima777/nvim (github.com)</a>,其中大部分是根据彭启阳同学在OS课程分享的配置更改的。</p><h2 id="1-nvim-treesitter">1. nvim-treesitter</h2><p><a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter</a>是一款具有<strong>代码高亮</strong>，<strong>增量选择</strong>，<strong>代码格式化</strong>以及<strong>折叠代码块</strong>的功能，后面三个我暂时还没用上。</p><p>在安装语言解析器(parser)的时候，对于<code>yaml</code>和<code>html</code>两种语言的时候一直出现错误，报错信息大概是<code>Impossible to load parser for html: Failed to load parser</code>。</p><p>后面在<a href="https://github.com/nvim-treesitter/nvim-treesitter/issues/3587">issue</a>里面找到了相似的问题，原因就是这两种语言在解析器里会使用c++，需要c++的标准库，然后nvim自带的libstdc+±6.dll和gcc的冲突，解决方法就是改变编译器,<code>zig</code>或者<code>clang</code>都可以。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;nvim-treesitter.install&#x27;</span>).compilers = &#123;<span class="string">&quot;zig&quot;</span>, <span class="string">&quot;gcc&quot;</span>, <span class="string">&quot;clang&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-内置终端">2. 内置终端</h2><p>在Windows下nvim的内置终端选择的是cmd，用着很不舒服，可以通过以下命令将其改成powershell。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell = vim.fn.executable <span class="string">&quot;pwsh&quot;</span> == <span class="number">1</span> <span class="keyword">and</span> <span class="string">&quot;pwsh&quot;</span> <span class="keyword">or</span> <span class="string">&quot;powershell&quot;</span>,</span><br><span class="line">shellcmdflag = <span class="string">&quot;-NoLogo -NoProfile -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;&quot;</span>,</span><br><span class="line">shellredir = <span class="string">&quot;-RedirectStandardOutput %s -NoNewWindow -Wait&quot;</span>,</span><br><span class="line">shellpipe = <span class="string">&quot;2&gt;&amp;1 | Out-File -Encoding UTF8 %s; exit $LastExitCode&quot;</span>,</span><br><span class="line">shellquote = <span class="string">&quot;&quot;</span>,</span><br><span class="line">shellxquote = <span class="string">&quot;&quot;</span>,</span><br></pre></td></tr></table></figure><h2 id="3-nvim-tree">3. nvim-tree</h2><p><a href="https://github.com/nvim-tree/nvim-tree.lua">nvim-tree</a>是一款文件管理的插件，可以显示git等信息。</p><p>但是在文件排序的时候默认会根据字典序排，如果遇到数字的话就会出现<code>1,10,2</code>这样的顺序，根据<a href="https://github.com/nvim-tree/nvim-tree.lua/discussions/1896">issue</a>配置就可以解决这个问题了。</p><h2 id="4-code-runner">4. code_runner</h2><p><a href="https://github.com/CRAG666/code_runner.nvim">code_runner</a>是一款快速运行文件或者项目的插件，通过参数设置可以配置对应文件或者项目的运行命令。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filetype = &#123;</span><br><span class="line">    c = <span class="string">&#x27;cd %:p:h &amp;&amp; gcc -g -Wall -lm -std=c11 % -o .\\bin\\$fileNameWithoutExt &amp;&amp; .\\bin\\$fileNameWithoutExt&#x27;</span>,</span><br><span class="line">    cpp = <span class="string">&#x27;cd %:p:h &amp;&amp; g++ -g -O2 -Wall -lm -std=c++17 % -o .\\bin\\$fileNameWithoutExt &amp;&amp; .\\bin\\$fileNameWithoutExt&#x27;</span>,</span><br><span class="line">    lua = <span class="string">&#x27;lua&#x27;</span>,</span><br><span class="line">    python = <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    sh = <span class="string">&#x27;bash&#x27;</span>,</span><br><span class="line">    dosbatch = <span class="string">&#x27;cd $dir &amp;&amp; %&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我目前只需要单文件的运行，所以并不是很复杂，其中带<code>$</code>的参数都是code_runner的内置变量，<code>dir</code>代表打开文件的目录，<code>fileName</code>代表文件名，<code>file</code>代表文件路径，<code>fileNameWithoutExt</code>代表没有后缀的文件名。<code>%</code>等是vim的内置变量，详见<a href="https://vimdoc.sourceforge.net/htmldoc/cmdline.html#filename-modifiers">vim 文档</a>。需要注意的是如果不使用code_runner的内置变量那么命令最后会自己加上文件名。</p>]]></content>
    
    
    <summary type="html">记录配置neovim时遇到的问题</summary>
    
    
    
    <category term="vim" scheme="https://makima777.github.io/categories/vim/"/>
    
    
    <category term="vim" scheme="https://makima777.github.io/tags/vim/"/>
    
    <category term="nvim" scheme="https://makima777.github.io/tags/nvim/"/>
    
  </entry>
  
  <entry>
    <title>hello-hexo</title>
    <link href="https://makima777.github.io/posts/b68a7456.html"/>
    <id>https://makima777.github.io/posts/b68a7456.html</id>
    <published>2023-04-11T12:36:39.000Z</published>
    <updated>2023-04-14T15:57:29.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文记录Hexo博客搭建过程中的修改配置，主要基于<a href="https://github.com/fomalhaut1998/hexo-theme-Fomalhaut">Fomalhaut</a>大佬分享的配置进行修改。</p><h2 id="Front-matter">Front-matter</h2><p><code>Front-matter</code> 是 markdown 文件最上方以<code>---</code>分隔的区域，用于指定个别档案的变数。</p><h3 id="Page-Front-matter-页面配置">Page Front-matter 页面配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>title</td><td style="text-align:center">[必需]页面标题</td></tr><tr><td>date</td><td style="text-align:center">[必需]页面创建时间</td></tr><tr><td>updated</td><td style="text-align:center">[可选]页面更新日期</td></tr><tr><td>type</td><td style="text-align:center">[必需]标签、分类以及友情链接三个页面需要配置</td></tr><tr><td>comments</td><td style="text-align:center">[可选]显示页面评论模块(默认 true)</td></tr><tr><td>description</td><td style="text-align:center">[可选]页面描述</td></tr><tr><td>keywords</td><td style="text-align:center">[可选]页面关键词</td></tr><tr><td>top_img</td><td style="text-align:center">[可选]页面顶部图片</td></tr><tr><td>mathjax</td><td style="text-align:center">[可选]显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td style="text-align:center">[可选]显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td style="text-align:center">[可选]显示侧边栏(默认 true)</td></tr><tr><td>aplayer</td><td style="text-align:center">[可选]在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td style="text-align:center">[可选]配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置,我设置为 true)</td></tr></tbody></table><h3 id="Post-Front-matter">Post Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">aside:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>title</td><td style="text-align:center">[必需]文章标题</td></tr><tr><td>date</td><td style="text-align:center">[必需]文章创建时间</td></tr><tr><td>updated</td><td style="text-align:center">[可选]文章更新日期</td></tr><tr><td>tags</td><td style="text-align:center">[可选]文章标签</td></tr><tr><td>categories</td><td style="text-align:center">[可选]文章分类</td></tr><tr><td>keywords</td><td style="text-align:center">[可选]文章关键词</td></tr><tr><td>description</td><td style="text-align:center">[可选]文章描述</td></tr><tr><td>top_img</td><td style="text-align:center">[可选]文章顶部图片</td></tr><tr><td>comments</td><td style="text-align:center">[可选]显示文章评论模块(默认 true)</td></tr><tr><td>cover</td><td style="text-align:center">[可选]文章缩略图</td></tr><tr><td>toc</td><td style="text-align:center">[可选]显示文章TOC(默认为设置中toc的enable配置,我设置为 true)</td></tr><tr><td>toc_number</td><td style="text-align:center">[可选]显示toc_number(默认为设置中toc的number配置,我设置为 true)</td></tr><tr><td>toc_style_simple</td><td style="text-align:center">[可选]显示 toc 简洁模式</td></tr><tr><td>copyright</td><td style="text-align:center">[可选]显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td style="text-align:center">[可选]文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td style="text-align:center">[可选]文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td style="text-align:center">[可选]文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td style="text-align:center">[可选]文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td style="text-align:center">[可选]显示mathjax(当设置mathjax的per_page: false时，才需要配置,默认 false)</td></tr><tr><td>katex</td><td style="text-align:center">[可选]显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td style="text-align:center">[可选]显示侧边栏(默认 true)</td></tr><tr><td>aplayer</td><td style="text-align:center">[可选]在需要的文章加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td style="text-align:center">[可选]配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h2 id="图床设置">图床设置</h2><h3 id="Github-PicGo-typora">Github + PicGo + typora</h3><p>在github中新建一个仓库作为图床，使用typora插入图片的时候可以通过<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>上传到github中。</p><h3 id="PicGo">PicGo</h3><p>具体配置部分，勾选需要显示的图床(默认全部显示)<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304123035.png" alt="image-20230412113035788"></p><p>在图床设置内选中相应的图床进行设置</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122929.png" alt="image-20230412112929180"></p><p>其中图床配置名随意，仓库名按照 github用户名/创建的仓库名 的格式填入即可，分支名输入仓库默认分支即可，Token需要创建，在github页面点击右上角头像<code>Settings-&gt;Developer settings-&gt;personal access tokens-&gt;token(classic)</code>，然后点击<code>Generate new token(classic)</code></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122840.png" alt="image-20230412112840083"></p><p>Note随意，Expiration有效期选择No expiration(有效期过了之后似乎是需要续期的，嫌麻烦的话直接不设就行），需要注意的是生成之后token只会显示一次，需要复制下来填入上面显示的空里面。</p><p>储存路径就是在图片在仓库中的储存位置，例如img/就会在存在img文件夹内。</p><p>自定义域名我暂时还没用到，如果访问github很慢的话可能需要设置。</p><h3 id="typora">typora</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122705.png" alt="image-20230412112705624"></p><p>在<code>偏好设置-&gt;图像</code>中如上图设置即可，优先使用相对路径需要取消勾选，PicGo路径选择自己的安装路径即可，通过验证图片上传选项可以测试自己是否配置成功。</p><h3 id="PicGo插件">PicGo插件</h3><p>PicGo提供了很多优秀的插件，可以在<code>插件设置</code>中进行搜索安装。</p><h4 id="github-plus">github-plus</h4><p>在使用的时候会发现，光是在PicGo的相册中删除图片，github中储存的图片并不会消失，于是可以安装<a href="https://github.com/zWingz/picgo-plugin-github-plus">github-plus</a>插件，对操作进行同步，同时能够把远端的图片pull到相册中。</p><p>安装之后在PicGo设置中勾选githubPlus，然后设置和之前一样即可，token如果忘记了可以去设置中打开<code>配置文件</code>,里面记录了token复制即可(<s>虽然不知道这样真的有安全性吗，还有就是这个插件的token不会隐藏</s>)，接着需要将这个图床设置为默认图床，否则上传还是之前的github设置，即使取消勾选了。</p><p>这个插件还有一个比较好的地方就是他还支持gitee，只需要在origin那一个设置中选择即可。</p><h4 id="super-prefix">super-prefix</h4><p>这一款<a href="https://github.com/gclove/picgo-plugin-super-prefix">插件</a>是用于图片命名的，安装之后可以进行设置</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304123332.png" alt="image-20230412113332495"></p><p>文件名个性前缀就是设置图片的储存路径，例如图片名为202304123332，那么就会被储存在2023/04/12这个文件夹下，相当于按日期分类了，使用这个需要关掉PicGo的时间戳重命名。</p><p>目前我还没试过除了日期还能不能用其他的命名。</p><h2 id="参考以及好看的主题收录">参考以及好看的主题收录</h2><p><a href="https://www.fomal.cc/">Fomalhaut🥝</a></p><p><a href="https://github.com/hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next">hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next</a></p><p><a href="https://tzy1997.com/">唐志远の博客 (tzy1997.com)</a></p>]]></content>
    
    
    <summary type="html">Hexo 记录</summary>
    
    
    
    <category term="Hexo" scheme="https://makima777.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://makima777.github.io/tags/Hexo/"/>
    
    <category term="Butterfly" scheme="https://makima777.github.io/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>[BUAA OO Unit 1 HW4] 第一单元总结</title>
    <link href="https://makima777.github.io/posts/a1dc732f.html"/>
    <id>https://makima777.github.io/posts/a1dc732f.html</id>
    <published>2023-03-16T01:58:23.000Z</published>
    <updated>2023-04-12T15:06:25.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>第一单元的主题是表达式括号展开化简，初步体会面向对象的思想，学习使用类管理数据，分工协作的行为设计等。该单元一共有三次作业层层递进，逐步实现括号嵌套，自定义函数，三角函数和求导等功能。</p><h2 id="第一次作业">第一次作业</h2><p>第一次作业为多变量表达式括号展开，运算分为加、减、乘和乘方四种，括号深度至多为一层，UML类图如下图所示</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120229.png" alt="image-20230318195545580"></p><h3 id="架构">架构</h3><p>通过形式化表达可知表达式遵循<code>expr-&gt;term-&gt;factor</code>的结构，通过递归下降算法可以将这些部分给解析出来，和正则表达式相比支持迭代。</p><p>不难发现 $expr = \sum coe*x^{expX}*y^{expY}*z^{expZ}$,其实无论是factor或者term都可以表示成上述式子，于是为了可以将其统一成<code>Operator</code>类进行计算。同时为了便于同类项的合并，将 $x^{expX}*y^{expY}*z^{expZ}$ 封装成<code>Unit</code>类，<code>Operator</code>采用HashMap进行储存，其中key为<code>Unit</code>，value为<code>coe</code>。</p><p>本次作业的因子<code>Pow</code>和<code>Number</code>都继承<code>Operator</code>类，<code>Parse</code>类中方法的返回值都为<code>Operator</code>，于是对于<code>Operator</code>来说只需要实现加法和乘法即可，同类项合并以及括号展开都是在这个过程中实现的。</p><h3 id="复杂度分析">复杂度分析</h3><p>本次作业部分方法复杂度如下，其余方法复杂度较低</p><ul><li>CogC:认知复杂度，代码被阅读和理解的复杂程度</li><li>ev(G):衡量程序非结构化程度</li><li>iv(G):衡量模块判定结构即模块和其他模块的调用关系，模块设计复杂度高意味着模块耦合度高</li><li>v(G):衡量模块判定结构复杂度，数量上表现为独立路径的条数(与循环以及条件语句有关)，圈复杂度大会导致难以测试和维护</li></ul><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120452.png" alt="image-20230316201823884"></p><p>总的复杂度不算太高，对于<code>Operator</code>的<code>toString</code>方法因为需要选出一个正项先输出，就导致需要额外一次对HashMap的遍历，其实也不是很有必要。</p><h3 id="Bug分析">Bug分析</h3><p>中测出现以下错误</p><ul><li>解析数字因子的时候忘记还有符号了</li><li>在解析指数之后没有进行<code>lexer.next()</code>的操作</li><li><code>isConstant</code>方法将其中的 $expZ$ 写成 $expX$ 了，导致会将 $z^y$ 判断为不含未知数</li></ul><p>强测和互测没有出现bug</p><h3 id="tips">tips</h3><ul><li>HashMap以类作为键值通常判断相等是基于两个类的地址来说，也就是是否是同一个实例，所以想要通过内部元素判断相等就得重写hashcode和equal函数，判断过程为如果hashcode不等为不等，否则通过equal函数判断，所以hashcode作为基础判断只需要保证构造的函数使得相等对象hashcode相同即可，想要简单的话也可以返回统一值跳过这一判断。</li><li>预处理将空白符去掉，<code>**</code>变成<code>^</code>方便判断</li><li>对于连续的±号并未提前处理，对于项之前的符号用sign传入<code>parseTerm</code>方法中，对于数字则是在<code>parseFactor</code>中进行处理</li><li>优化：<ol><li>$x**2$-&gt;$x*x$</li><li>将正的项先输出</li><li>对于系数为$\pm1$且含有未知数因子的项不输出1</li></ol></li></ul><h2 id="第二次作业">第二次作业</h2><p>第二次作业支持括号嵌套，新增三角函数因子和自定义函数因子，UML类图如下图所示</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120459.png" alt="image-20230318200106301"></p><h3 id="架构-2">架构</h3><p>对于三角函数的处理，<code>Unit</code>需要表示为 $x^{expX}*y^{expY}<em>z^{expZ}</em>\prod(sin(expr_i))\prod(cos(expr_i))$ ，为了便于输出与合并同样采用HashMap储存三角函数，key值为expr即<code>Operator</code>类，value值为该三角函数的指数部分，新增继承<code>Operator</code>的<code>Sin</code>和<code>Cos</code>类进行构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unit.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Operator, Integer&gt; sinMap;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Operator, Integer&gt; cosMap;</span><br></pre></td></tr></table></figure><p>对于自定义函数的处理，新增<code>Definer</code>类处理自定义函数的定义和调用，所有成员以及方法都是静态的，直接采用类名调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,String&gt; funcMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt; paraMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">funcPattern</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;funcName&gt;[fgh])\\((?&lt;para&gt;.*)\\)=(?&lt;expr&gt;.*)&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">paraPattern</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;para&gt;[xyz]),?&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addFunc</span><span class="params">(String input)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">callFunc</span><span class="params">(String funcName,ArrayList&lt;Operator&gt; actualPara)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>addFunc</code>内部采用正则表达式分割自定义函数各部分。<code>callFunc</code>调用的时候传入的实参是<code>Operator</code>类的，也可以调用它的<code>toString</code>方法传入String类型的数组,具体过程是按字符遍历函数定义式，如果是参数就用对应位置的实参替换(不是在原String替换，而是新建一个StringBuilder)。</p><p>同时新增<code>Function</code>类储存调用之后得到的表达式，同时可以将此表达式解析成<code>Operator</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String expr;</span><br><span class="line"><span class="keyword">public</span> Operator <span class="title function_">expandExpr</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在<code>Parse</code>中新增<code>parseFunction</code>方法，内部使用<code>parseFactor</code>读取实参列表，接着使用<code>callFunc</code>得到新的表达式，再返回<code>expandExpr</code>即可。</p><p>这次调整了一下<code>Parse</code>内部解析因子的方法，将对数字、未知数、三角函数和指数等的解析用方法封装了起来，指数的处理在需要的方法内进行，使得未知数以及三角函数的指数不用通过乘法实现而是直接赋值，总体来说可读性和可维护性提高了。</p><h3 id="复杂度分析-2">复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120513.png" alt="image-20230317103249850"></p><p>部分方法复杂度如上，<code>Unit</code>中的<code>equals</code>复杂度高是因为采用涉及两个HashMap的相等判断，先用if判断了size其次使用for循环判断元素是否存在映射，主要是sin和cos虽然结构类似但是由于采用两个容器储存，导致不能进行统一处理，结果出现了很多的重复性工作，这一缺点在输出等地方均存在。<code>Operator</code>的<code>equals</code>也是由于HashMap的相等判断。</p><h3 id="Bug分析-2">Bug分析</h3><p>中测</p><ul><li>就像上面说的一样，因为Cos和Sin很多类似的操作，所以复制代码结果导致一些地方没有修改到（<s>复制是坏文明</s></li><li>$cos(0)=0$</li></ul><p>强测和互测</p><ul><li>$sin(0)^0=0$</li><li>比较表达式相等的时候忘记比较系数了，导致$sin(x)+sin(2x)=2sin(x)$</li></ul><p>互测过程中有一个同学没有处理自定义函数中的空白字符(<s>帮我挽回了一点分数</s></p><h3 id="tips-2">tips</h3><ul><li>对于函数实参的代入不能直接<code>replaceAll</code>，不然可能将已替换实参中的未知数替换掉，研讨课某些同学提出将<code>xyz</code>换成<code>pqr</code>等没出现的字符(<s>可行不过没有可拓展性</s>)，还有使用java中的<code>MessageFormat</code>类替换的。</li><li>传入实参需要在左右两侧加括号。</li></ul><h2 id="第三次作业">第三次作业</h2><p>第三次作业新增求导因子，函数定义时可以调用已有函数，函数定义中的求导因子先求导再代入实参,UML类图如下</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120518.png" alt="image-20230318204703578"></p><h3 id="架构-3">架构</h3><p>这次主要就是在<code>Operator</code>和<code>Unit</code>分别加入求导的方法,通过乘法法则和链式法则等返回新的表达式,需要注意的是<code>Unit</code>采用乘法法则需要深拷贝。</p><p>其次函数在定义的时候先进行解析操作去掉求导因子，于是将解析字符串的操作封装在<code>Definer</code>方法中(<s><code>Function</code>显得更没必要了</s>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Operator <span class="title function_">simplifyExpr</span><span class="params">(String expr)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Lexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lexer</span>(expr);</span><br><span class="line">    <span class="type">Parser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parser</span>(lexer);</span><br><span class="line">    <span class="keyword">return</span> parser.parseExpr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3">复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120524.png" alt="image-20230317112423675"></p><p>部分方法复杂度如上，自己比较习惯将一些模块化的部分封装成方法进行调用，所以复杂度看上去还好，不然的话某些方法会很臃肿复杂度可能也会很高，不过也会导致方法很多的问题。</p><h3 id="tips-3">tips</h3><ul><li>第二次作业中sin输出内部因子无脑加了层括号，在这一次判断了是否是单因子，减少括号输出，主要有数字，幂函数，三角函数这三种情况，不过由于 $x^2$ 会输出为$x*x$，所以需要特判一下。</li></ul><h3 id="Bug分析-3">Bug分析</h3><p>中测</p><ul><li>主要bug就出在上面所说的优化判断，细节没有考虑好</li></ul><p>强测和互测没有bug。</p><h2 id="反思与体会">反思与体会</h2><ul><li>还是比较面向过程，主打的就是<strong>everything is Operator</strong>，没有将各模块解耦合，都集中在<code>Operator</code>和<code>Unit</code>两个部分，理想的架构应该是先解析出式子，再实现括号展开以及化简，用老师的话来说就是可以将每部分的工作交给不同的程序员来做。</li><li><code>Number</code>等单因子虽然继承了<code>Operator</code>但是实际上没有什么自己的feature，只是为了方便构造或者理解，有些鸡肋。</li><li><code>Unit</code>中指数的部分是用三个数分别储存的，对于后面可能的迭代开发并不是很有利，而且在某些方法中需要进行一个一个判断，应该使用HashMap储存会更加合理。</li><li>作业中对三角函数做过多的优化，只是在构造的时候对sin(0)和cos(0)进行了简单的判断，不过也多亏了是边构造边化简的形式，当然也是架构的问题导致过程中不太能做更多的三角优化，除非最后再进行一次化简。</li><li>三角函数没做统一处理，导致很多重复性的工作，后面再出现其余的三角函数的话，就需要继续同样的操作，应该合并成一个类在里面存有三角函数名。</li><li>这次就只有没测试的第二次作业出问题了(<s>虽然第一次和第三次都是用的大佬的评测机</s>),深深体会到了评测的必要性。</li><li>OO的讨论区有很多大佬分享自己的架构经验以及评测等等，没有思路的时候可以多看看。</li></ul>]]></content>
    
    
    <summary type="html">总结OO课程第一单元表达式化简作业</summary>
    
    
    
    <category term="面向对象" scheme="https://makima777.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="BUAA" scheme="https://makima777.github.io/tags/BUAA/"/>
    
    <category term="表达式化简" scheme="https://makima777.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%96%E7%AE%80/"/>
    
    <category term="JAVA" scheme="https://makima777.github.io/tags/JAVA/"/>
    
  </entry>
  
</feed>
