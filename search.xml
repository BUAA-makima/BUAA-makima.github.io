<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[BUAA OO Unit 3 HW12] 第三单元总结</title>
      <link href="/posts/667e9628.html"/>
      <url>/posts/667e9628.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>第三单元的主题是规格化设计，主要是理解如何根据规格进行代码实现，如何撰写规格以及规格撰写和代码实现的区别等。三次作业简单来说就是对课程组给出的规格进行翻译，不过需要注意部分方法的实现性能。</p><p>关于JML学习，(<s>感觉现在也没人学这个了</s>)，课程组给出的JML-level0已经说的比较简洁详细了，总结了所有这次作业可能用到的语法等，还有部分拓展，我也写了一篇<a href="https://makima777.github.io/posts/54aa4121.html">笔记</a>。(<s>也没简洁多少，主要是记录</s>)</p><h2 id="第一次作业"><a class="markdownIt-Anchor" href="#第一次作业"></a> 第一次作业</h2><p>第一次作业为简单的社交关系的模拟和查询，通过<code>Network</code>和<code>Person</code>维护社交网络的图并询问某些图的特性，同时需要对某些非法的指令进行异常抛出和记录相关信息。</p><h3 id="代码架构"><a class="markdownIt-Anchor" href="#代码架构"></a> 代码架构</h3><p>总的架构课程组已经给出了，可能有一点创意的地方就在于异常的设计，我使用了 <strong><a href="https://www.runoob.com/design-pattern/factory-pattern.html">工厂模式</a></strong> 进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExceptionManager.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;Exceptions, HashMap&lt;Integer,Integer&gt;&gt; allCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;Exceptions,Integer&gt; total = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在<code>ExceptionManager</code>里面维护两个容器分别是某种异常下各种id的触发次数以及某种异常的总触发次数，当需要抛出异常的时候就进行信息的更新，大致的形式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExceptionManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Exception <span class="title function_">getException</span><span class="params">(Exceptions exceptionType,<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    addTotalException(exceptionType);</span><br><span class="line">    addPersonException(exceptionType,id);</span><br><span class="line">    <span class="keyword">switch</span> (exceptionType) &#123;</span><br><span class="line">        <span class="keyword">case</span> PersonIdNotFound:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPersonIdNotFoundException</span>(id);</span><br><span class="line">        <span class="keyword">case</span> EqualPersonId:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyEqualPersonIdException</span>(id);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Exception <span class="title function_">getException</span><span class="params">(Exceptions exceptionType,<span class="type">int</span> id1,<span class="type">int</span> id2)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要两个id的异常同理，只需要特判一下id大小和是否相同进行相应维护即可。</p><p>因为我把成员都设成了静态，异常构造时直接进行相关查询即可。</p><p>在<code>Network</code>抛出异常时为了程序美观和代码复用我也进行了封装，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">throwPersonIdNotFound</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> PersonIdNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!contains(id)) &#123;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> ExceptionsManager.getException(Exceptions.PersonIdNotFound,id);</span><br><span class="line">        <span class="keyword">assert</span> exception != <span class="literal">null</span> : <span class="string">&quot;PersonIdNotFound == null!&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> (PersonIdNotFoundException) exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也不太需要工厂模式，因为这样写也需要在<code>NetWork</code>中对每一种异常写一个方法，不过要是课程组让这些异常都继承自一个带<code>print</code>方法的异常，那么只需要一或者两个方法即可，就很简洁很多，现在这样感觉有太多无意义的重复，比如各种异常之间并没有联系(比如单参数和双参数可以分为一类等的关系)。</p><h3 id="部分方法实现"><a class="markdownIt-Anchor" href="#部分方法实现"></a> 部分方法实现</h3><h4 id="iscircle-queryblocksum"><a class="markdownIt-Anchor" href="#iscircle-queryblocksum"></a> isCircle &amp; queryBlockSum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network.java</span></span><br><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">  @ requires contains(id1) &amp;&amp; contains(id2);</span></span><br><span class="line"><span class="comment">  @ ensures \result == (\exists Person[] array; array.length &gt;= 2;</span></span><br><span class="line"><span class="comment">  @                     array[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">  @                     array[array.length - 1].equals(getPerson(id2)) &amp;&amp;</span></span><br><span class="line"><span class="comment">  @                      (\forall int i; 0 &lt;= i &amp;&amp; i &lt; array.length - 1;</span></span><br><span class="line"><span class="comment">  @                      array[i].isLinked(array[i + 1]) == true));</span></span><br><span class="line"><span class="comment">  @ also</span></span><br><span class="line"><span class="comment">  @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">  @ signals (PersonIdNotFoundException e) !contains(id1);</span></span><br><span class="line"><span class="comment">  @ signals (PersonIdNotFoundException e) contains(id1) &amp;&amp; !contains(id2);</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">boolean</span> <span class="title function_">isCircle</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span> <span class="keyword">throws</span> PersonIdNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*@ ensures \result ==</span></span><br><span class="line"><span class="comment">  @         (\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length &amp;&amp;</span></span><br><span class="line"><span class="comment">  @         (\forall int j; 0 &lt;= j &amp;&amp; j &lt; i; !isCircle(people[i].getId(), people[j].getId()));</span></span><br><span class="line"><span class="comment">  @         1);</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryBlockSum</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><code>isCircle</code>判断两个点是否连通。</p><p><code>queryBlockSum</code>其实就是图中联通块的数量<strong>blocks</strong>，因为对答案有贡献的点满足它之前(某种顺序)的所有点都和它不连通，对于一个联通块在这种顺序下最靠前的点x必然可以产生1的贡献，而其他的点由于x的存在不能产生贡献，所以答案就是联通块数量。</p><p>比较经典的连通性和联通块维护就是通过并查集，通过路径压缩或者按秩合并可以达到一个比较优秀的复杂度(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>左右，结合使用会更低)，并查集的直接作用时判断两个点是否在一个联通块也就是<code>isCircle</code>需要的，而联通块动态维护即可:</p><ol><li>加入人的时候，<strong>blocks</strong>＋1</li><li>当加入关系的两人不连通时，<strong>blocks</strong>-1</li></ol><p>当然上述两种查询通过<strong>dfs</strong>或者<strong>bfs</strong>进行搜索也是可以的，只要打上<strong>vis</strong>标记避免重复遍历即可，只是复杂度相较之下略高(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>)。</p><h4 id="querytriplesum"><a class="markdownIt-Anchor" href="#querytriplesum"></a> queryTripleSum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network.java</span></span><br><span class="line"><span class="comment">/*@ ensures \result ==</span></span><br><span class="line"><span class="comment">  @         (\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length;</span></span><br><span class="line"><span class="comment">  @             (\sum int j; i &lt; j &amp;&amp; j &lt; people.length;</span></span><br><span class="line"><span class="comment">  @                 (\sum int k; j &lt; k &amp;&amp; k &lt; people.length</span></span><br><span class="line"><span class="comment">  @                     &amp;&amp; getPerson(people[i].getId()).isLinked(getPerson(people[j].getId()))</span></span><br><span class="line"><span class="comment">  @                     &amp;&amp; getPerson(people[j].getId()).isLinked(getPerson(people[k].getId()))</span></span><br><span class="line"><span class="comment">  @                     &amp;&amp; getPerson(people[k].getId()).isLinked(getPerson(people[i].getId()));</span></span><br><span class="line"><span class="comment">  @                     1)));</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryTripleSum</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>查询三元环的数量，也可以进行动态维护，每次加入关系(边)，通过遍历其中一人认识的人，如果另一个人也认识这个人那么总的答案＋1，这种时候选取认识的人更少的一方进行遍历会更好，当然直接遍历整个网络的人也是可以的，虽然最差复杂度一致但是实际上前者肯定会快不少。</p><h2 id="第二次作业"><a class="markdownIt-Anchor" href="#第二次作业"></a> 第二次作业</h2><p>第二次作业加入了<code>Message</code>和<code>Group</code>，模拟群组和消息的功能。</p><h3 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h3><p>因为<code>Group</code>的加入，让某些异常的判断条件不再唯一，所以之前说的抛出异常的方法进行了以下修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">throwPersonIdNotFound</span><span class="params">(<span class="type">boolean</span> check,<span class="type">int</span> id)</span> <span class="keyword">throws</span> PersonIdNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (check) &#123;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> ExceptionsManager.getException(Exceptions.PersonIdNotFound,id);</span><br><span class="line">        <span class="keyword">assert</span> exception != <span class="literal">null</span> : <span class="string">&quot;PersonIdNotFound == null!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> (PersonIdNotFoundException) exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然更加规范化了，但是让我更难受了，因为各类方法更加趋同了却不能合并。</p><h3 id="部分方法实现-2"><a class="markdownIt-Anchor" href="#部分方法实现-2"></a> 部分方法实现</h3><h4 id="modifyrelation"><a class="markdownIt-Anchor" href="#modifyrelation"></a> modifyRelation</h4><p>规格很长，简单来说就是修改两个点的边权，如果修改后边权为非正数那么删除这条边。</p><p>修改后为正数很简单，主要考虑删除边的情况会造成什么影响:</p><ol><li>三元环数量需要进行更新</li><li>连通性<strong>可能</strong>发生改变</li></ol><p>对于第一个影响很简单只需要照着加边进行修改即可，因此可以合并成一个方法，设置对答案的影响参数(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pm 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord">1</span></span></span></span>)即可。</p><p>对于第二个影响，删边对连通性可能有影响也可能没影响，但是没有一种优秀(比重构更快)的方法进行判断，并且由于并查集没有删除操作，因此如果还要继续使用并查集的话就需要对并查集进行重构，可以像之前说的使用搜索进行部分重构——只修改与这两个点连通的点。</p><p>先从一个点进行搜索，将搜到的点的父亲都设为这个点，结束后如果另一个点没有<strong>vis</strong>标记说明产生了新的联通块，令<strong>blocks</strong>+1然后同样的方式从这个点进行搜索更新它所在的联通块的点的父亲信息，总体复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h4 id="getagemean-getagevar"><a class="markdownIt-Anchor" href="#getagemean-getagevar"></a> getAgeMean &amp; getAgeVar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group.java</span></span><br><span class="line"><span class="comment">/*@ ensures \result == (people.length == 0? 0:</span></span><br><span class="line"><span class="comment">  @          ((\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getAge()) / people.length));</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">getAgeMean</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*@ ensures \result == (people.length == 0? 0 : ((\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length; </span></span><br><span class="line"><span class="comment">  @          (people[i].getAge() - getAgeMean()) * (people[i].getAge() - getAgeMean())) / </span></span><br><span class="line"><span class="comment">  @           people.length));</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">getAgeVar</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>分别是求组内成员年龄平均值和方差。</p><p>对于前者可以动态维护组内成员年龄和，对于后者可以进行以下公式推导:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mi>g</mi><mi>e</mi><mi>V</mi><mi>a</mi><mi>r</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>g</mi><msub><mi>e</mi><mi>i</mi></msub><mo>−</mo><mi>a</mi><mi>g</mi><mi>e</mi><mi>M</mi><mi>e</mi><mi>a</mi><mi>n</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mrow><mi>n</mi></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mo>∑</mo><mrow><mi>a</mi><mi>g</mi><msubsup><mi>e</mi><mi>i</mi><mn>2</mn></msubsup></mrow><mo>−</mo><mn>2</mn><mo>∗</mo><mo>∑</mo><mrow><mi>a</mi><mi>g</mi><msub><mi>e</mi><mi>i</mi></msub><mo>∗</mo><mi>a</mi><mi>g</mi><mi>e</mi><mi>M</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow><mo>+</mo><mi>n</mi><mo>∗</mo><mi>a</mi><mi>g</mi><mi>e</mi><mi>M</mi><mi>e</mi><mi>a</mi><msup><mi>n</mi><mn>2</mn></msup></mrow><mi>n</mi></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mo>∑</mo><mrow><mi>a</mi><mi>g</mi><msubsup><mi>e</mi><mi>i</mi><mn>2</mn></msubsup></mrow><mo>−</mo><mn>2</mn><mo>∗</mo><mi>a</mi><mi>g</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo>∗</mo><mi>a</mi><mi>g</mi><mi>e</mi><mi>M</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo>+</mo><mi>n</mi><mo>∗</mo><mi>a</mi><mi>g</mi><mi>e</mi><mi>M</mi><mi>e</mi><mi>a</mi><msup><mi>n</mi><mn>2</mn></msup></mrow><mi>n</mi></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}ageVar&amp;=\frac{\sum{(age_i-ageMean)^2}}{n}\\&amp;=\frac{\sum{age_i^2}-2*\sum{age_i*ageMean}+n*ageMean^2}{n}\\&amp;=\frac{\sum{age_i^2}-2*ageSum*ageMean+n*ageMean^2}{n}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.431323999999999em;vertical-align:-3.465662em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.965661999999999em;"><span style="top:-5.965661999999999em;"><span class="pstrut" style="height:3.491108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.4885539999999997em;"><span class="pstrut" style="height:3.491108em;"></span><span class="mord"></span></span><span style="top:-1.0114460000000003em;"><span class="pstrut" style="height:3.491108em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.465662em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.965661999999999em;"><span style="top:-5.965661999999999em;"><span class="pstrut" style="height:3.491108em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911079999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.4885539999999997em;"><span class="pstrut" style="height:3.491108em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.0114460000000003em;"><span class="pstrut" style="height:3.491108em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.465662em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>因此只需要再维护一个组内成员年龄平方和即可。</p><p>需要注意的是，使用到的除法是向下整除，所以不能轻易地将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>g</mi><mi>e</mi><mi>M</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">ageMean</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mi>g</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{ageSum}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>然后进行消除，因为这种情况下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mfrac><mrow><mi>a</mi><mi>g</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi></mrow><mi>n</mi></mfrac><mi mathvariant="normal">≠</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">n*\frac{ageSum}{n}\neq ageSum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>。</p><h4 id="querybestacquaintance-querycouplesum"><a class="markdownIt-Anchor" href="#querybestacquaintance-querycouplesum"></a> queryBestAcquaintance &amp; queryCoupleSum</h4><p>前者查询与某个点的最大边权的边(根据定义唯一)连接的点，后者查询互相满足前者条件的点对数。</p><p>前者可以考虑对每个点动态维护各自的<strong>bestAcquaintance</strong>，在加边、更改边权以及删边的时候进行更新，加边只需要判断是否能成为<strong>bestAcquaintance</strong>即可，而后两者在改动为当前的<strong>bestAcquaintance</strong>时就需要从集合中进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>遍历更新。</p><p>对于后者则不考虑动态维护了，因为改动是跟随着每一次点的<strong>bestAcquaintance</strong>的，但是两者不是同一层次的，要是改动对边权的改动都在<code>Network</code>倒也好说，但偏偏<code>Group</code>内也会修改边权，强行维护也不是不行，但整体就不是很美观了，比较零散后期拓展性可能不是很客观，所以直接选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>查询就好了(前面已经保证了<strong>bestAcquaintance</strong>查询是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的)。</p><h4 id="querygroupvaluesum"><a class="markdownIt-Anchor" href="#querygroupvaluesum"></a> queryGroupValueSum</h4><p>查询组内各成员之间的边权和，不太好动态维护，因为边权修改部分在<code>Network</code>和<code>Person</code>，<code>Group</code>相当于高<code>Person</code>一级，如果动态维护的话就得再让每个人记录所在的组，然后进行某种判断，感觉性能也不会很优秀，所以最后打算直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>求了。</p><h4 id="sendmessage"><a class="markdownIt-Anchor" href="#sendmessage"></a> sendMessage</h4><p>并不复杂，只是需要注意课程组对于下标的要求，所以对于这个数据的维护需要用有序容器，比如<strong>ArrayList</strong>或者<strong>LinkedList</strong>，由于需要在首位插入，所以后者复杂度更加优秀。</p><h2 id="第三次作业"><a class="markdownIt-Anchor" href="#第三次作业"></a> 第三次作业</h2><p>第三次作业增加了继承自<code>Message</code>的<code>EmojiMessage</code>和<code>RedEnvelope</code>以及<code>NoticeMessage</code>，实现不同消息的类型以及相关操作。</p><h3 id="部分方法实现-3"><a class="markdownIt-Anchor" href="#部分方法实现-3"></a> 部分方法实现</h3><h4 id="deletecoldemoji"><a class="markdownIt-Anchor" href="#deletecoldemoji"></a> deleteColdEmoji</h4><p>删除包含的<strong>emoji</strong>热度低于<strong>limit</strong>的<code>EmojiMessage</code>以及相应的<strong>emoji</strong>，已经维护了每个<strong>emoji</strong>的热度。</p><p>删除有以下两种方式:</p><ol><li>删除信息可以遍历信息然后判断是否是<code>EmojiMessage</code>并且包含的<strong>emoji</strong>热度是否低于<strong>limit</strong>，然后进行删除信息，最后遍历<strong>emoji</strong>集合删除相关<strong>emoji</strong>。</li><li>再开一个集合<strong>emojiMessages</strong>对每个<strong>emoji</strong>记录包含该<strong>emoji</strong>的<code>EmojiMessage</code>，删除操作遍历<strong>emoji</strong>集合然后对需要删除的<strong>emoji</strong>根据<strong>emojiMessages</strong>进行删除，然后删除<strong>emoji</strong>。</li></ol><p>前者操作简便，后者复杂度更优秀。</p><p>我选择的是后者，对于<strong>emojiMessages</strong>需要进行动态维护，在以下几个地方:</p><ol><li><p>储存<strong>emoji</strong>时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emojiMessages.put(id,<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br></pre></td></tr></table></figure></li><li><p>发送信息时，需要将信息移除集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emojiMessages.get(((EmojiMessage) message).getEmojiId()).remove(message.getId());</span><br></pre></td></tr></table></figure></li><li><p>添加信息时，将信息加入集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emojiMessages.get(((EmojiMessage) message).getEmojiId()).add(message.getId());</span><br></pre></td></tr></table></figure></li></ol><p>然后关于遍历删除我在上个单元的作业已经讲过了，需要使用迭代器。</p><h4 id="queryleastmoments"><a class="markdownIt-Anchor" href="#queryleastmoments"></a> queryLeastMoments</h4><p>查询包含某个点x的最小环(边权和，至少3个点)。</p><p>最小环一定可以由最小生成树再加上一条非树边组成，以x为根节点的话，非树边(&lt;u,v&gt;)需要满足的条件就是</p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>=</mo><mo>=</mo><mi>x</mi><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mi>d</mi><mi>e</mi><mi>p</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>≥</mo><mn>3</mn><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>v</mi><mo>=</mo><mo>=</mo><mi>x</mi><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mi>d</mi><mi>e</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>≥</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u == x \ \&amp;\&amp;\  dep[v] \ge 3)\ ||\ (v==x\ \&amp;\&amp;\ dep[u]\ge3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord">∣</span><span class="mord">∣</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi mathvariant="normal">≠</mi><mi>x</mi><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mi>v</mi><mi mathvariant="normal">≠</mi><mi>x</mi><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mi>L</mi><mi>C</mi><mi>A</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">u\ne x\ \&amp;\&amp;\ v\ne x\ \&amp;\&amp;\ LCA(u,x)==x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li></ol><p>**LCA(u,v)**就是两者的最近公共祖先。</p><p>实现部分可以考虑使用<code>Dijkstra</code>算法+枚举边，其实<code>prim</code>算法和<code>Dijkstra</code>差不太多，最短路的前驱结点就是该结点的父亲结点，所以通过<code>Dijkstra</code>算法可以得到一颗最小生成树，最短路径就是该结点到源点(根节点)的边权和。关于深度和<strong>LCA</strong>部分真正按照定义实现的话稍显复杂，简单的做法就是记录每个点的最短路是从哪个点延伸出来的，也就是它深度为2的祖先是谁，然后判断就好了。</p><p>具体实现时，由于朴素的<code>Dijkstra</code>时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的复杂度，可以加入堆优化实现达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>级别，在稠密图中复杂度前者会更优，但就本题而言稠密图时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的范围并不大，相较之下还是后者好。</p><p>结点的封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id; <span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> from; <span class="comment">// 之前说的深度为2的祖先</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> values; <span class="comment">// 最短路</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">add</span><span class="params">(<span class="type">int</span> origin, <span class="type">int</span> id, <span class="type">int</span> values)</span> &#123;</span><br><span class="line">    <span class="comment">// 从当前节点加上一条边,origin-源点,id-边的另一个点的id,values-边权</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(id, <span class="built_in">this</span>.id == origin ? id : <span class="built_in">this</span>.from, <span class="built_in">this</span>.values + values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node node)</span> &#123;<span class="keyword">return</span> Integer.compare(values,node.values);&#125; <span class="comment">// 用于堆的比较</span></span><br></pre></td></tr></table></figure><p>遍历边的部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network.java</span></span><br><span class="line"><span class="keyword">for</span> (Integer id1 : people.keySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!minPath.containsKey(id1)) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> minPath.get(id1);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : map.get(id1).entrySet()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="keyword">if</span> (!minPath.containsKey(id2)) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> minPath.get(id2);</span><br><span class="line">        <span class="keyword">if</span> (x.getFrom() == y.getFrom()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.getId() == id &amp;&amp; y.getFrom() == y.getId()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (y.getId() == id &amp;&amp; x.getFrom() == x.getId()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        minAns = Integer.min(minAns,x.getValues() + y.getValues() + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化部分"><a class="markdownIt-Anchor" href="#优化部分"></a> 优化部分</h5><p>其实可以发现在更新最短路的过程中，对于每一条边肯定会到达一个状态就是x和y都已经得到了最短路(否则就会更新y的最短路，然后再次枚举这条边)，而此时就可以进行答案的更新，而当不都是最短路的时候也可以更新只是答案不正确而已，所以我们就可以在求最短路的过程中进行更新答案，这样的好处在于可以根据当前已有答案减少不必要的遍历，即当已有答案已经大于当前点x的最短路时，就可以从最短路循环中<strong>break</strong>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLeastCircle</span><span class="params">(<span class="type">int</span> id,HashMap&lt;Integer,HashMap&lt;Integer,Integer&gt;&gt; map)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Node&gt; minPath = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer,Boolean&gt; vis = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minAns</span> <span class="operator">=</span> Parameters.maxValue;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(id,id,<span class="number">0</span>);</span><br><span class="line">    queue.add(node);</span><br><span class="line">    minPath.put(node.getId(),node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (minPath.get(x.getId()).getValues() &gt; minAns) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis.containsKey(x.getId())) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        vis.put(x.getId(),<span class="literal">true</span>);</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; dis = map.get(x.getId());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : dis.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idY</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> x.add(id,idY,value);</span><br><span class="line">            <span class="keyword">if</span> (!minPath.containsKey(idY) || y.compareTo(minPath.get(idY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(y);</span><br><span class="line">                minPath.put(idY,y);</span><br><span class="line">            &#125;</span><br><span class="line">            y = minPath.get(idY);</span><br><span class="line">            <span class="keyword">if</span> (x.getFrom() == y.getFrom()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (x.getId() == id &amp;&amp; y.getFrom() == y.getId()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (idY == id &amp;&amp; x.getFrom() == x.getId()) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            minAns = Integer.min(minAns,x.getValues() + y.getValues() + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试过程"><a class="markdownIt-Anchor" href="#测试过程"></a> 测试过程</h2><h3 id="黑白箱测试"><a class="markdownIt-Anchor" href="#黑白箱测试"></a> 黑白箱测试</h3><blockquote><p>黑箱测试：测试者不需要了解程序的内部实现细节和结构，只是通过观察输入和输出是否符合预期来验证程序是否正确运行。黑箱测试的目的是验证程序的功能和行为是否正确，是站在用户的角度来说的。</p></blockquote><blockquote><p>白箱测试：测试者需要了解程序的内部实现细节和结构，可以检查程序的逻辑路径、条件覆盖、循环覆盖等，并使用这些信息设计测试用例和执行测试。白箱测试的目标是验证程序的内部逻辑是否正确，确保代码按照预期方式工作，通常由开发者执行。</p></blockquote><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p>用于验证系统的最小的可测试单元，如方法、类等的正确性，通过确保每个代码单元都能够按照预期工作从而确保整个系统的正确性。单元测试的主要目的是隔离和测试代码单元，以验证其功能是否正确、边界条件是否处理正确、异常情况是否被处理等。</p><h3 id="功能测试"><a class="markdownIt-Anchor" href="#功能测试"></a> 功能测试</h3><p>旨在验证程序的功能是否符合预期，主要关注程序在各种输入条件下的输出和行为，以确保程序按照用户需求和规格说明正确地执行。</p><h3 id="集成测试"><a class="markdownIt-Anchor" href="#集成测试"></a> 集成测试</h3><p>用于测试不同组件、模块或子系统之间的集成和交互，其目的是验证各个组件在集成后能否正常协同工作，以确保系统在整体上具有正确的功能、性能和稳定性。</p><h3 id="压力测试"><a class="markdownIt-Anchor" href="#压力测试"></a> 压力测试</h3><p>用于评估系统在负载压力下的性能和稳定性，通过模拟高负载条件和极限情况来测试系统的响应能力、吞吐量、资源利用率和错误处理能力。在作业中表现为对时间和内存的限制。</p><h3 id="回归测试"><a class="markdownIt-Anchor" href="#回归测试"></a> 回归测试</h3><p>用于验证修改或更新后的程序在进行修改之前的功能和性能的基础上是否仍然正确运行，它的目的是确保修改没有引入新的错误或者对现有功能产生负面影响。</p><h3 id="测试工具-数据生成"><a class="markdownIt-Anchor" href="#测试工具-数据生成"></a> 测试工具 &amp; 数据生成</h3><p>手动感谢权佬的测试工具和群友的数据，测试原理大概是数据生成器+对拍。</p><p>数据生成很麻烦，随机生成的话强度不是很高，需要考虑生成不同类的样例：</p><ol><li>检测异常抛出是否正确</li><li>完成上述验证后需要减少无效的指令，针对稀疏图、稠密图等构造数据，或者像单元测试一样针对某个指令构造数据</li></ol><p>还有OKTest的数据就基本上只能手动根据规格进行构造了。</p><h2 id="架构分析"><a class="markdownIt-Anchor" href="#架构分析"></a> 架构分析</h2><h3 id="图模型"><a class="markdownIt-Anchor" href="#图模型"></a> 图模型</h3><p>没有专门另外维护图的结构，课程组规格给出的结构就相当于是一个图了，<code>Network</code>记录了所有点，<code>Person</code>记录了和它相连的点以及对应的边权(类似前向星可能)，至于<code>Group</code>其实相当于是子图。</p><h3 id="维护策略"><a class="markdownIt-Anchor" href="#维护策略"></a> 维护策略</h3><p>需要维护的信息大部分都在前面说了，性能大体是没啥问题的，除了<strong>GroupValueSum</strong>，要是课程组加入大量的点进同一个组，并且多次查询的话，可能会超时，可能的解决方法就是遍历的时候第二维变成组员的集合和人认识的人的集合的较小的一个。</p><h2 id="规格和实现分离"><a class="markdownIt-Anchor" href="#规格和实现分离"></a> 规格和实现分离</h2><p>像荣文戈老师说的，规格化设计就是一种契约，是客户和程序员之间的约定，对于规格中的要求不同的人可以有不同的实现方法，只要保证满足条件即可，例如容器的选择、以及数据结构和算法的选择，比如课程组在<strong>tripleSum</strong>的规格中使用了三重循环，实际实现显然不能这样操作，否则直接T飞掉。</p><h2 id="oktest"><a class="markdownIt-Anchor" href="#oktest"></a> OKTest</h2><p>OKTest通过方法执行前后的数据判断方法是否正确按照规格执行，判断过程需要使用规格提供的方法才能保证严格的正确性，不过OKTest实际上也是黑盒测试，还是比较依赖于数据构造的。</p><p>OKTest的判断过程是根据规格来的，然而规格其实也有挺多的表述方式的，所以想要OKTest简单的话对规格的要求也挺高的，如何采用完备并且简单的规格也是一门技术活(<s>虽然荣文戈老师多次强调规格不必考虑实际实现方法</s>)。</p><h2 id="bug分析"><a class="markdownIt-Anchor" href="#bug分析"></a> Bug分析</h2><p>第一次作业强测错了一个点是关于<code>queryTripleSumOKTest</code>的，因为我是直接三层循环枚举的，所以最后统计结果需要 <strong>/6</strong>，但是我却只 <strong>/3</strong>。</p><p>第二次作业<strong>OKTest</strong>有一个地方<strong>after</strong>和<strong>before</strong>写反了，第三次作业<strong>emojiMessages</strong>维护以及<strong>OKTest</strong>出现了问题，最后强测都是100。</p><p>(<s>上述错误中测都没测出来，不得不说是真水</s>)</p><h2 id="体会与感想"><a class="markdownIt-Anchor" href="#体会与感想"></a> 体会与感想</h2><ul><li><p>设计相比于代码实现更加困难，如果设计出现问题，修改起来更加耗费人力物力，本次单元对规格化设计只是相当于在门口驻足观望，重点在于如何实现规格，而更加重要的撰写需要自己去深挖了，这绝对是对自我的提升，无论是考虑问题的角度还是经验的积累。</p></li><li><p>课程组在架构上的设计可能存在部分不足，比如前面说过的异常的问题，大量的异常但是没有什么本质上的区别，完全可以继承自一个异常，没有必要各自继承，这样也导致实现的时候大量的重复代码却由于抛出异常类型的限制无法合并；还有某些异常抛出不合理，比如<strong>delFromGroup</strong>方法的第三个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@signals</span> (EqualPersonIdException e) (\exists <span class="type">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; groups.length;</span><br><span class="line">@          groups[i].getId() == id2) &amp;&amp; (\exists <span class="type">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; people.length;</span><br><span class="line">@           people[i].getId() == id1) &amp;&amp; !getGroup(id2).hasPerson(getPerson(id1));</span><br></pre></td></tr></table></figure><p>实在不能理解为什么不是<strong>PersonIdNotFoundException</strong>；除此之外，规格好像不是很统一，比如判断<code>Network</code>是否存在某个人的时候，某些地方使用<strong>contains</strong>，某些地方又使用<strong>forall</strong>去重复了一遍前者的规格。当然我也很理解，JML确实很难写，助教也需要兼顾自己的学业，所以难免会出现疏漏。</p></li><li><p>关于动态维护这个问题，我觉得可以动态维护的东西，应该尽量是同一层面上的东西，换句话说不会修改或者修改只在这个地方，比如组内求关于年龄的相关数据，所有成员的年龄都是固定的，所以很容易维护；然而关于<strong>ValueSum</strong>，它既是改变的，同时改变又发生在<code>Network</code>和<code>Person</code>内部，这个过程基本上不会经过<code>Group</code>，维护就很麻烦。</p><p>不过动态维护对于后期迭代可能不是很友好，需要经常注意到对这些动态变量的修改，忘记了的话就会导致结果错误，所以实际上就是简便和性能的抉择。</p></li><li><p>不得不说的是，<strong>JML</strong>没有高亮再加上臃肿的描述，使得阅读过程变得十分困难，不过主要的还是学会规格化设计的思想，而不是这个淘汰的语言。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> JAVA </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JML-level0</title>
      <link href="/posts/54aa4121.html"/>
      <url>/posts/54aa4121.html</url>
      
        <content type="html"><![CDATA[<h2 id="注释结构"><a class="markdownIt-Anchor" href="#注释结构"></a> 注释结构</h2><p>JML以javadoc注释的方式来表示规格，每行以<code>@</code>起头，有行注释和块注释两种方式。</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">行注释</button></li><li class="tab"><button type="button" data-href="#-2">块注释</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ public model non_nul int [] elements</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public model non_nul int [] elements</span></span><br><span class="line"><span class="comment">  @ ...</span></span><br><span class="line"><span class="comment">  @*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="jml表达式"><a class="markdownIt-Anchor" href="#jml表达式"></a> JML表达式</h2><h3 id="原子表达式"><a class="markdownIt-Anchor" href="#原子表达式"></a> 原子表达式</h3><h4 id="result"><a class="markdownIt-Anchor" href="#result"></a> <code>\result</code></h4><p>表示一个非<code>void</code>类型的方法执行所获得的结果，即方法执行后的返回值，类型为方法声明中定义的返回值类型。</p><h4 id="oldexpr"><a class="markdownIt-Anchor" href="#oldexpr"></a> <code>\old(expr)</code></h4><p>用来表示一个表达式<code>expr</code>在方法执行前的取值，对于一个对象引用而言只能判断引用本身是否发生变化，而不判断指向的对象实体是否发生变化，即引用是否改变所指的对象。(这的引用更像C++的指针)</p><p>例如对于<code>HashMap</code>类型的<code>v</code>而言，<code>\old(v).size()</code>和<code>\old(v.size())</code>含义不同，前者是取了<code>v</code>在方法执行前的对象再使用方法，如果<code>v</code>没有改变所指的对象的话，即使有插入删除操作，<code>\old(v).size()</code>和<code>v.size()</code>也一样，而后者是取的执行方法前的值。</p><p>因而，任何情况下都应该使用<code>\old</code>将关心的表达式整体括起来。</p><h4 id="not_assignedxy"><a class="markdownIt-Anchor" href="#not_assignedxy"></a> <code>\not_assigned(x,y,...)</code></h4><p>表示括号中的变量是否在方法执行过程中被赋值，没有则返回<code>true</code>，否则为<code>false</code>。一般用于后置条件的约束表示上，限制方法的实现不能对列表中的变量赋值。</p><h4 id="not_modifiedxy"><a class="markdownIt-Anchor" href="#not_modifiedxy"></a> <code>\not_modified(x,y,...)</code></h4><p>与上面类似，限制列表中的变量在方法执行过程中取值不变。</p><h4 id="nonnullelementscontainer"><a class="markdownIt-Anchor" href="#nonnullelementscontainer"></a> <code>\nonnullelements(container)</code></h4><p>表示<code>container</code>对象中储存的对象不会有<code>null</code>，等价于下面的断言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container != <span class="literal">null</span> &amp;&amp; (\forall <span class="type">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; container.length; container[i] != <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h4 id="typetype"><a class="markdownIt-Anchor" href="#typetype"></a> <code>\type(type)</code></h4><p>返回类型type对应的类型(Class)，如<code>\type(boolean)</code>为<code>Boolean.TYPE</code>，``TYPE<code>是JML采用的缩略表示，等同于Java中的</code>java.lang.Class`。</p><h4 id="typeofexpr"><a class="markdownIt-Anchor" href="#typeofexpr"></a> <code>\typeof(expr)</code></h4><p>返回表达式对应的准确类型，如<code>\typeof(true)</code>为<code>Boolean.TYPE</code>。</p><h3 id="量化表达式"><a class="markdownIt-Anchor" href="#量化表达式"></a> 量化表达式</h3><h4 id="forall"><a class="markdownIt-Anchor" href="#forall"></a> <code>\forall</code></h4><p>全称量词修饰的表达式，表示对给定范围内的元素，每个元素都满足相应的约束，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\forall <span class="type">int</span> i,j; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; j &amp;&amp; j &lt; <span class="number">10</span>; a[i] &lt; a[j])</span><br></pre></td></tr></table></figure><p>为真(<code>ture</code>)则表示a数组升序排列(在[0,10))</p><h4 id="exists"><a class="markdownIt-Anchor" href="#exists"></a> <code>\exists</code></h4><p>存在量词修饰的表达式，表示对于给定范围内的元素，存在某个元素满足满足相应的约束。</p><h4 id="sum"><a class="markdownIt-Anchor" href="#sum"></a> <code>\sum</code></h4><p>返回给定范围内表达式的和，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\sum <span class="type">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; <span class="number">5</span>; i * i)</span><br></pre></td></tr></table></figure><p>返回结果为30 (0+1+4+9+16)</p><h4 id="product"><a class="markdownIt-Anchor" href="#product"></a> <code>\product</code></h4><p>返回给定范围内表达式的连乘结果。</p><h4 id="max"><a class="markdownIt-Anchor" href="#max"></a> <code>\max</code></h4><p>返回给定范围内表达式的最大值。</p><h4 id="min"><a class="markdownIt-Anchor" href="#min"></a> <code>\min</code></h4><p>返回给定范围内表达式的最小值。</p><h4 id="num_of"><a class="markdownIt-Anchor" href="#num_of"></a> <code>\num_of</code></h4><p>返回指定变量中满足相应条件的取值个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(\num_of T x; R(x); P(x))</span><br><span class="line">(\sum T x; R(x) &amp;&amp; P(x); <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>R(x)</code>为变量范围，<code>P(x)</code>为约束条件。</p><h3 id="集合表达式"><a class="markdownIt-Anchor" href="#集合表达式"></a> 集合表达式</h3><p>可以在JML中构造一个局部的集合(容器)，明确集合中可以包含的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">JMLObjectSet</span> &#123;Integer i | s.contains(i) &amp;&amp; <span class="number">0</span> &lt; i.intValue()&#125;</span><br></pre></td></tr></table></figure><p>表示构造一个<code>JMLObjectSet</code>对象其中包含元素类型为<code>Integer</code>，该集合元素均在容器集合s中出现且为正数。(容器集合值Java中构建的容器，如ArrayList)</p><p>一般形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ST</span> &#123;T x | R(x) &amp;&amp; P(x)&#125;</span><br></pre></td></tr></table></figure><p><code>R(x)</code>表示x的范围通常来自某个既有集合，<code>P(x)</code>为约束条件。</p><h3 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h3><p>JML表达式可以正常使用Java所定义的操作符，包括运算操作符、逻辑操作符等。此外，JML定义了以下四类操作符。</p><h4 id="子类型关系操作符-e1e2"><a class="markdownIt-Anchor" href="#子类型关系操作符-e1e2"></a> 子类型关系操作符 <code>E1&lt;:E2</code></h4><p>如果类型<code>E1</code>是类型<code>E2</code>的子类型，表达式为真，否则为假。(类型相同也为真)</p><p>显然任意类X满足<code>X.TYPE&lt;:Object.TYPE</code>。</p><h4 id="等价关系操作符-b_expr1b_expr2或者b_expr1b_expr2"><a class="markdownIt-Anchor" href="#等价关系操作符-b_expr1b_expr2或者b_expr1b_expr2"></a> 等价关系操作符 <code>b_expr1&lt;==&gt;b_expr2</code>或者<code>b_expr1&lt;=!=&gt;b_expr2</code></h4><p>其中<code>b_expr1</code>和<code>b_expr2</code>都是布尔表达式，这两种运算符和Java的<code>==</code>、<code>!=</code>具有相同的效果，但等价关系操作符的优先级更低。</p><h4 id="推理操作符-b_expr1b_expr2或者b_expr2b_expr1"><a class="markdownIt-Anchor" href="#推理操作符-b_expr1b_expr2或者b_expr2b_expr1"></a> 推理操作符 <code>b_expr1==&gt;b_expr2</code>或者<code>b_expr2&lt;==b_expr1</code></h4><p>相当于蕴含式，当且仅当<code>b_expr1</code>为真且<code>b_expr2</code>为假时表达式为假。</p><h4 id="变量引用操作符"><a class="markdownIt-Anchor" href="#变量引用操作符"></a> 变量引用操作符</h4><p>除了可以直接引用Java代码或者JML规格中定义的变量外，JML还提供了几个概括性的关键词来引用相关的变量。</p><p><code>\nothing</code>表示一个空集。</p><p><code>\everything</code>表示一个全集，即当前作用域下能访问到的所有变量。</p><p>变量引用操作符常在<code>\assignable</code>句子中使用。</p><h2 id="方法规格"><a class="markdownIt-Anchor" href="#方法规格"></a> 方法规格</h2><p>方法规格的核心分为三个方面——前置条件、后置条件和副作用。</p><p>前置条件：对方法输入参数的限制，如果不满足前置条件则方法的执行结果不可预测，或者是不保证结果的正确性。</p><p>后置条件：对方法执行结果的限制，执行结果满足后置条件则方法执行正确，否则错误。</p><p>副作用：方法在执行过程中对输入对象或者<code>this</code>对象进行了修改。</p><p>两类方法——全部过程和局部过程。</p><p>全部过程：前置条件恒为真，可以适应于任意调用场景。</p><p>局部过程：提供非恒真的前置条件，需要对不符合前置条件的输入情况进行处理，往往对应着异常处理。</p><p>JML区分这两种场景分别对应着正常行为规格(normal_behavior)和异常行为规格(exceptional_behavior)。</p><h3 id="前置条件pre-condition"><a class="markdownIt-Anchor" href="#前置条件pre-condition"></a> 前置条件(pre-condition)</h3><p>通过requires子句来表示:<code>requires P;</code>，表示要求调用者确保P为真。</p><p>可以有多个requires子句，是并列关系，即调用者必须满足所有子句要求。</p><p>想设计或逻辑则应使用一个requires子句，<code>requires P1 || P2;</code>。</p><h3 id="后置条件post-condition"><a class="markdownIt-Anchor" href="#后置条件post-condition"></a> 后置条件(post-condition)</h3><p>通过ensures子句来表示:<code>ensures P;</code>，表示方法实现者确保方法执行结果一定满足P的要求，即P为真。</p><p>ensures子句同样是并列关系，必须同时满足，或逻辑实现应使用一个ensures子句。</p><h3 id="副作用范围限定side-effects"><a class="markdownIt-Anchor" href="#副作用范围限定side-effects"></a> 副作用范围限定(side-effects)</h3><p>副作用指方法在执行过程中会修改对象的属性数据或者类的静态成员数据，从而给后续方法执行带来影响，必须明确给出副作用的范围。</p><p>使用关键词<code>assignable</code>或者<code>modifiable</code>,前者表示可赋值，后者表示可修改，大部分情况下可交换使用。</p><p>约束子句有两种形态——使用JML关键词概括或者指明具体的变量列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerSet</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList&lt;Integer&gt; elements;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer max;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer min;</span><br><span class="line"><span class="comment">/*@</span></span><br><span class="line"><span class="comment">  @ assignable \nothing;</span></span><br><span class="line"><span class="comment">  @ assignable \everything;</span></span><br><span class="line"><span class="comment">  @ modifiable \nothing;</span></span><br><span class="line"><span class="comment">  @ modifiable \everthing;</span></span><br><span class="line"><span class="comment">  @ assignable elements;</span></span><br><span class="line"><span class="comment">  @ modifiable elements;</span></span><br><span class="line"><span class="comment">  @ assignable elements, max, min;</span></span><br><span class="line"><span class="comment">  @ modifiable elements, max, min;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>JML不允许在副作用约束子句中指定规格声明的变量数据，因为这样的声明只是为了描述规格，并不意味实现者一定要实现这样的数据。</li><li>默认情况下，方法的规格对调用者可见，但是方法所在类的成员变量一般都声明为private,对调用者不可见。有时方法规格不得不使用类的成员变量来限制方法的行为，比如上面例子中的副作用范围限定，这就和类对相应成员变量的私有化保护产生了冲突。为了解决这个问题，JML提供了/<em>@spec_public@</em>/来注释一个类的私有成员变量，表示在规格中可以直接使用，从而调用者可见。</li></ol></blockquote><p>对于某些纯粹访问性的方法，不会对对象状态进行修改也不需要输入参数，这样的方法无需描述前置条件也不会有副作用，且一定能正常结束，可以使用<code>pure</code>关键词描述其规格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@ ensures \result == bachelor || \result == master;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">getStatus</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@ ensures \result &gt;= 0;</span></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">getCredits</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>在方法规格中可以引用<code>pure</code>方法返回的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ requires c &gt;= 0;</span></span><br><span class="line"><span class="comment">  @ ensures getCredits() == \old(getCredits()) + c;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCredits</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><p>为了有效的区分方法的正常功能行为和异常行为，JML提供了这两类行为的区分机制，可以明确 按照这两类行为来分别描述方法的规格，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">  @ requires z &lt;= 99;</span></span><br><span class="line"><span class="comment">  @ assignable \nothing;</span></span><br><span class="line"><span class="comment">  @ ensures \result &gt; z;</span></span><br><span class="line"><span class="comment">  @ also</span></span><br><span class="line"><span class="comment">  @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">  @ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">  @ assignable \nothing;</span></span><br><span class="line"><span class="comment">  @ signals (IllegalArgumentException e) true;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cantBeSatisfied</span><span class="params">(<span class="type">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException；</span><br></pre></td></tr></table></figure><p>其中<code>public normal_behavior</code>表示接下来的部分对<code>cantBeSatisfied(int z)</code>方法的正常功能给出规格。所谓正常功能，一般指输入或方法关联<code>this</code>对象的状态在正常范围内时所指向的功能。与正常功能相对应的是异常功能，即<code>public exceptional_behavior</code>下面所定义的规格。</p><p>其中的<code>public</code>指相应的规格在所在包范围内的所有其他规格处都可见。</p><p>需要说明的是，如果一个方法没有异常处理行为，则无需区分正常功能规格和异常功能规格，因而也就不必使用这两个关键词。</p><p>上面例子中出现了一个关键词<code>also</code>，它的意思是除了正常功能规格外，还有一个异常功能规格。需要说明的是，按照JML语言规范定义，有两种使用also的场景:</p><ol><li>父类中对相应方法定义了规格，子类重写了该方法，需要补充规格，这时应该在补充的规格之前使用<code>also</code>。</li><li>一个方法规格中涉及多个功能规格描述，正常功能规格或者异常功能规格，需要使用<code>also</code>来分隔。</li></ol><blockquote><p>作为一种重要的设计原则，同一个方法的正常功能前置条件和异常功能前置条件一定不能有重叠。对于上面的例子而言，如果正常功能前置条件修改为 z&gt;=0 就能满足这个要求。可以看出不论是正常功能规格，或者是异常功能规格，都包括前置条件、后置条件和副作用声明。不同的是，异常功能规格中，后置条件常常表示为抛出异常，使用signals子句来表示。</p></blockquote><h4 id="signals"><a class="markdownIt-Anchor" href="#signals"></a> signals</h4><p><code>signals</code>子句的结构为<code>signals (***Exception e) b_expr</code>，意思是当<code>b_expr</code>为真时，方法抛出括号中给出的相应异常e。</p><p>抛出的异常既可以是Java预先定义的异常类型，也可以是用户自定义的异常类型。</p><p>如果一个方法在运行时会抛出异常，一定要在方法声明中明确指出(使用Java的<code>throws</code>表达式)，且必须确保<code>signals</code>子句中给出的异常类型一定等同于方法声明中给出的异常类型，或者是后者的子类型。</p><p>还有一个简化的<code>signals</code>子句，即<code>signals_only</code>子句，后面跟着一个异常类型。<code>signals</code>子句强调在对象状态满足某个条件时会抛出符合相应类型的异常；而<code>signals_only</code>则不强调对象状态条件，强调满足前置条件时抛出相应的异常。</p><p>有时，为了更明显地区分异常，会针对输入参数的取值范围抛出不同的异常，从而提醒调用者进行不同的处理。这时可以使用多个<code>exceptional_behavior</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="comment">//@ public model non_null int[] credits;</span></span><br><span class="line"><span class="comment">/*@ normal_behavior</span></span><br><span class="line"><span class="comment">  @ requires z &gt;=0 &amp;&amp; z &lt;= 100;</span></span><br><span class="line"><span class="comment">  @ assignable \nothing;</span></span><br><span class="line"><span class="comment">  @ ensures \result == credits.length;</span></span><br><span class="line"><span class="comment">  @ also</span></span><br><span class="line"><span class="comment">  @ exceptional_behavior</span></span><br><span class="line"><span class="comment">  @ requires z &lt; 0;</span></span><br><span class="line"><span class="comment">  @ assignable \nothing;</span></span><br><span class="line"><span class="comment">  @ signals_only IllegalArgumentException;</span></span><br><span class="line"><span class="comment">  @ also</span></span><br><span class="line"><span class="comment">  @ exceptional_behavior</span></span><br><span class="line"><span class="comment">  @ requires z &gt; 100;</span></span><br><span class="line"><span class="comment">  @ assignable \nothing;</span></span><br><span class="line"><span class="comment">  @ signals_only OverFlowException;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recordCredit</span><span class="params">(<span class="type">int</span> z)</span> <span class="keyword">throws</span> IllegalArgumentException,</span><br><span class="line">OverFlowException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要指出的是，在异常功能规格中，除了抛出异常，也一样可以正常使用ensures子句来描述方法执行产生的其他结果。</p><h2 id="类型规格"><a class="markdownIt-Anchor" href="#类型规格"></a> 类型规格</h2><p>类型规格是针对Java程序中定义的数据类型所设计的限制规则。一般而言，就是针对类或接口所设计的约束规则。</p><p>从面向对象角度来看，类或接口包含数据成员和方法成员的声明及（或）实现。不失一般性，一个类型的成员要么是静态成员(static member)，要么是实例成员(instance member)。一个类的静态方法不可以访问这个类的非静态成员变量(即实例变量)。静态成员可以直接通过类型引用，而实例成员只能通过实例化对象来引用。因此，在设计和表示类型规格时需要加以区分。</p><p>JML针对类型规格定义了多种限制规则，本课程主要涉及两类——不变式限制(invariant)和约束限制(constraint)。无论哪种，类型规格都是针对类型中定义的数据成员的限制规则，一旦违反就称相应的状态有错。</p><h3 id="不变式"><a class="markdownIt-Anchor" href="#不变式"></a> 不变式</h3><p>要求在所有**可见状态(visible state)**下都必须满足的特性，语法上定义为<code>invariant P</code>，<code>P</code>为谓词。</p><p><strong>可见状态</strong>一般指在特定时刻下对一个对象状态的观察，下述对象o的状态都是可见状态:</p><ol><li>对象的有状态构造方法（用来初始化对象成员变量初值）的执行<strong>结束</strong>时刻</li><li>在调用一个对象回收方法（<code>finilize</code>方法）来释放相关资源<strong>开始</strong>的时刻</li><li>在调用对象o非静态、有状态方法（non-helper）的开始和结束时刻</li><li>在调用对象o对应的类或父类的静态、有状态方法的开始和结束时刻</li><li>在未处于对象o的构造方法、回收方法、非静态方法被调用过程中的任意时刻</li><li>在未处于对象o对应类或者父类的静态方法被调用过程中的任意时刻</li></ol><blockquote><p>凡是会修改成员变量(包括静态和非静态)的方法执行期间，对象的状态都是不可见的(其本质原因是对象的状态修改未完成，此时观察到的状态可能不完整)。</p></blockquote><p>类型规格强调在任意可见状态下都要满足不变式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Path</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> ArrayList &lt;Integer&gt; seq_nodes;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer start_node;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> Integer end_node;</span><br><span class="line"><span class="comment">/*@ invariant seq_nodes != null &amp;&amp;</span></span><br><span class="line"><span class="comment">  @ seq_nodes[0] == start_node &amp;&amp;</span></span><br><span class="line"><span class="comment">  @ seq_nodes[seq_nodes.legnth-1] == end_node &amp;&amp;</span></span><br><span class="line"><span class="comment">  @ seq_nodes.length &gt;=2;</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以包括多个不变式，相互独立。</p><p>不变式中可以直接引用<code>pure</code>状态方法。</p><p>对应类成员变量有静态和非静态之分，JML也区分两类不变式，静态不变式(static invariant)和实例不变式(instance invariant)。其中静态不变式只针对类中的静态成员变量取值进行约束，实例不变式则可以针对静态成员变量和非静态成员变量的取值进行约束。可以在不变式定义中明确使用<code>instance invariant</code>或者<code>static invariant</code>来表示不变式的类别。</p><h3 id="状态变化约束"><a class="markdownIt-Anchor" href="#状态变化约束"></a> 状态变化约束</h3><p>对象的状态在变化时往往也满足一些约束，这种约束本质上也是一种不变式。JML为了简化使用规则，规定<code>invariant</code>只针对可见状态（即当下可见状态）的取值进行约束，而使用<code>constraint</code>来对前序可见状态和当前可见状态的关系进行约束，如下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceCounter</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*@spec_public@*/</span> <span class="type">long</span> counter;</span><br><span class="line"><span class="comment">//@ invariant counter &gt;= 0;</span></span><br><span class="line"><span class="comment">//@ constraint counter == \old(counter)+1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>invariant</code>和<code>constraint</code>可以直接被子类继承获得。</p></blockquote><p>和不变式一样，JML也根据类的静态成员变量区分了两类约束：<code>static constraint</code>和<code>instance constraint</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> JAVA </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> JML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++primer-第一章&amp;第二章</title>
      <link href="/posts/5728e4e2.html"/>
      <url>/posts/5728e4e2.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章开始"><a class="markdownIt-Anchor" href="#第一章开始"></a> 第一章——开始</h2><h3 id="编译-运行程序"><a class="markdownIt-Anchor" href="#编译-运行程序"></a> 编译、运行程序</h3><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h4><p>访问main的返回值的方法依赖于系统，在UNIX和Windows系统中，执行完一个程序后，可以通过以下方法活得其返回值。</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">UNIX</button></li><li class="tab"><button type="button" data-href="#-2">cmd</button></li><li class="tab"><button type="button" data-href="#-3">powershell</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">%ERRORLEVEL%</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">echo</span>] <span class="variable">$</span>?</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>其中PowerShell的echo可有可无，如果程序返回值为0则显示为True，否则为False。</p><h3 id="初识输入输出"><a class="markdownIt-Anchor" href="#初识输入输出"></a> 初识输入输出</h3><h4 id="输入输出运算符"><a class="markdownIt-Anchor" href="#输入输出运算符"></a> 输入输出运算符</h4><p>以<strong>输出运算符</strong>(<code>&lt;&lt;</code>)为例，&lt;&lt;运算符接受两个运算对象，左侧的运算对象必须是一个<code>ostream</code>对象，右侧的运算对象就是要打印的值，此运算符将给定的值写到ostream对象中，输出运算符的结果就是其左侧运算对象，即该运算符的返回值为左侧的运算对象，所以以下两条语句等价</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">(std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="读取数量不定的输入数据"><a class="markdownIt-Anchor" href="#读取数量不定的输入数据"></a> 读取数量不定的输入数据</h4><p>当我们使用一个<code>istream</code>对象作为条件时，其效果就是检测流的状态。如果遇到文件结束符(<code>end-of-file</code>)，或遇到一个无效的输入(读取类型不匹配)时，istream对象的状态就会变为无效，出于无效状态的istream对象会使条件为假。</p><h4 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h4><p>默认情况下，读<code>cin</code>会刷新<code>cout</code>；程序非正常终止时也会刷新<code>cout</code>。</p><h4 id="cerr"><a class="markdownIt-Anchor" href="#cerr"></a> Cerr</h4><p>一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到cerr的数据是不缓冲的。</p><h4 id="clog"><a class="markdownIt-Anchor" href="#clog"></a> Clog</h4><p>一个ostream对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。</p><h2 id="变量与基本类型"><a class="markdownIt-Anchor" href="#变量与基本类型"></a> 变量与基本类型</h2><h3 id="基本内置类型"><a class="markdownIt-Anchor" href="#基本内置类型"></a> 基本内置类型</h3><p>C++定义了一套包括<strong>算术类型</strong>(<code>arithmetic type</code>)和<strong>空类型</strong>(<code>void</code>)在内的基本数据类型，其中算数类型包含了字符、整型数、布尔值和浮点数。</p><h4 id="字符型"><a class="markdownIt-Anchor" href="#字符型"></a> 字符型</h4><p>字符型被分为了三种<code>char</code>、<code>signed char</code>、<code>unsigned char</code>，但是尽管字符型有三种，字符的表现形式只有两种：带符号的不带符号的。类型char实际上会表现为上述的其中一种，具体是哪种由编译器决定。</p><h4 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h4><ul><li><p>将浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中小数点前的部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3.9999</span>; <span class="comment">// val = 3</span></span><br></pre></td></tr></table></figure></li><li><p>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示的数值总数取模后的余数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> val = <span class="number">-1</span>; <span class="comment">// val = 255</span></span><br></pre></td></tr></table></figure></li><li><p>赋给带符号类型一个超出它表示范围的值时，结果是<strong>未定义</strong>(<code>undefined</code>)的。</p></li><li><p>如果表达式里既有带符号类型又有无符号类型，那么带符号类型会自动转换成无符号类型。</p></li></ul><h4 id="字面值常量"><a class="markdownIt-Anchor" href="#字面值常量"></a> 字面值常量</h4><h5 id="整型和浮点型字面值"><a class="markdownIt-Anchor" href="#整型和浮点型字面值"></a> 整型和浮点型字面值</h5><ul><li><p>以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="comment">/*十进制*/</span>    <span class="number">024</span><span class="comment">/*八进制*/</span>    <span class="number">0x14</span><span class="comment">/*十六进制*/</span></span><br></pre></td></tr></table></figure></li><li><p>默认情况下，十进制字面值是带符号数，八进制和十六进制可能是带符号的也可能是不带符号的。类型会从能容纳其数值的最小尺寸者([unsigned] int, long, long long)，short类型没有其字面值。</p></li><li><p>默认的，浮点型字面值是一个double。</p></li></ul><h5 id="转义序列"><a class="markdownIt-Anchor" href="#转义序列"></a> 转义序列</h5><h6 id="关于问号"><a class="markdownIt-Anchor" href="#关于问号"></a> 关于问号</h6><p>问号也在转义序列中，主要是为了防止 <strong><a href="https://zh.cppreference.com/w/cpp/language/escape">三标符</a></strong> (<code>trigraph</code>），会在辨识注释和字面量之前被分析，如<code>??&lt;</code>会被编译成<code>&#123;</code>，不过三标符在<code>c++17</code>中已经被移除也就不需要转义了。(平常普通使用也不需要)</p><h6 id="泛化的转义序列"><a class="markdownIt-Anchor" href="#泛化的转义序列"></a> 泛化的转义序列</h6><p>其形式是<code>\x</code>后紧跟一个或多个十六进制数字，或者<code>\</code>后紧跟1-3个八进制数字。</p><p>如果反斜线后跟着的八进制数字超过3个，只有前3个数字构成转义序列。</p><p>相反，<code>\x</code>会用到后面跟着的所有数字，超过范围会报错。</p><h5 id="指定字面值的类型"><a class="markdownIt-Anchor" href="#指定字面值的类型"></a> 指定字面值的类型</h5><h6 id="字符和字符串字面值"><a class="markdownIt-Anchor" href="#字符和字符串字面值"></a> 字符和字符串字面值</h6><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">含义</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">Unicode16字符</td><td style="text-align:center">char16_t</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">Unicode32字符</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">宽字符</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center">u8</td><td style="text-align:center">UTF-8(仅用于字符串字面常量)</td><td style="text-align:center">char</td></tr></tbody></table><h6 id="整型字面值"><a class="markdownIt-Anchor" href="#整型字面值"></a> 整型字面值</h6><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">最小匹配类型</th></tr></thead><tbody><tr><td style="text-align:center">u or U</td><td style="text-align:center">unsigned</td></tr><tr><td style="text-align:center">l or L</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">ll or LL</td><td style="text-align:center">long long</td></tr></tbody></table><h6 id="浮点型字面值"><a class="markdownIt-Anchor" href="#浮点型字面值"></a> 浮点型字面值</h6><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">f or F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">l or L</td><td style="text-align:center">long double</td></tr></tbody></table><p>注意对于整型字面值，是规定其最小的匹配值，例如以<code>UL</code>为后缀的数据类型将根据具体数值或者取<code>unsigned long</code>，或者取<code>unsigned long long</code>。</p><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><h4 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h4><h5 id="初始值"><a class="markdownIt-Anchor" href="#初始值"></a> 初始值</h5><blockquote><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值替代。</p></blockquote><h5 id="列表初始化"><a class="markdownIt-Anchor" href="#列表初始化"></a> 列表初始化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> val = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> val&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>后两种初始化的形式被称为<strong>列表初始化</strong>(<code>list initialization</code>)，当用于内置类型的变量时，这种形式有一个重要特点:<code>如果我们使用列表初始化存在丢失信息的风险，则编译器将报错</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> val&#123;pi&#125;;</span><br><span class="line"><span class="comment">// Type &#x27;float&#x27; cannot be narrowed to &#x27;int&#x27; in initializer list (fix available)</span></span><br></pre></td></tr></table></figure><h5 id="默认初始化"><a class="markdownIt-Anchor" href="#默认初始化"></a> 默认初始化</h5><p>定义于函数体内的内置数据类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值由类确定。</p><h4 id="变量声明和定义的关系"><a class="markdownIt-Anchor" href="#变量声明和定义的关系"></a> 变量声明和定义的关系</h4><p><strong>声明</strong>(<code>declaration</code>)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>(<code>definition</code>)负责创建与名字相关联的实体。</p><p>变量声明规定了变量的类型和名字，在这一点上和定义相同，但定义还申请储存空间，也可能会为变量赋一个初值。</p><p>想声明一个变量而非定义，就在变量名前添加关键字<code>extern</code>，而且不要显示地初始化变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明i而非定义i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">//声明并定义j</span></span><br></pre></td></tr></table></figure><p><code>任何包含了显式初始化的声明即成为定义。</code>extern语句包含初始值就不再是声明而是定义，抵消掉了extern的作用。</p><blockquote><p>变量能且只能被定义一次，但是可以被多次声明。</p></blockquote><h3 id="复合类型"><a class="markdownIt-Anchor" href="#复合类型"></a> 复合类型</h3><h4 id="引用左值引用"><a class="markdownIt-Anchor" href="#引用左值引用"></a> 引用(左值引用)</h4><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。</p></blockquote><p>获取引用的值，实际上是获取了与引用绑定的对象的值。</p><h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4><p>指针与引用的不同点：</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向及规格不同的对象。</li><li>指针无须在定义时赋初值。</li></ol><blockquote><p>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p></blockquote><blockquote><p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p></blockquote><h3 id="const限定符"><a class="markdownIt-Anchor" href="#const限定符"></a> const限定符</h3><h4 id="const的引用"><a class="markdownIt-Anchor" href="#const的引用"></a> const的引用</h4><p><code>常量引用</code>实际上是<code>对const的引用</code>的简称。</p><h5 id="初始化和对const的引用"><a class="markdownIt-Anchor" href="#初始化和对const的引用"></a> 初始化和对const的引用</h5><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外，其中一个就是在初始化常量引用的时候允许使用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象，字面值，甚至是个一般表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>当一个常量引用被绑定到另外一种类型时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure><p>为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> temp = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure><p>在这种情况下，ri绑定了一个<strong>临时量</strong>(<code>temporary</code>)，临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象，上述r3也会进行这样的转换。(r2说不定也是，只是没法验证)</p><h5 id="对const的引用可能引用一个非const的对象"><a class="markdownIt-Anchor" href="#对const的引用可能引用一个非const的对象"></a> 对const的引用可能引用一个非const的对象</h5><blockquote><p>常量引用仅仅对引用可参与的操作作出了限定，对于引用的对象本身是否是一个常量未作限定，允许通过其他方式改变对象的值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;</span><br><span class="line">r2 = <span class="number">0</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>当通过r1修改i的值之后，r2的值实际上也变成了0；</p><h4 id="指针和const"><a class="markdownIt-Anchor" href="#指针和const"></a> 指针和const</h4><h5 id="指向常量的指针"><a class="markdownIt-Anchor" href="#指向常量的指针"></a> 指向常量的指针</h5><p>类似常量引用，<strong>指向常量的指针</strong>(<code>pointer to const</code>)不能用于修改所指对象的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;</span><br></pre></td></tr></table></figure><p>指针类型必须与其所指对象的类型一致，但是有两个例外，其中一个就是允许一个指向常量的指针指向一个非常量的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval;</span><br></pre></td></tr></table></figure><blockquote><p>与常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，对象本身可以通过其他方式改变。</p></blockquote><h5 id="const指针"><a class="markdownIt-Anchor" href="#const指针"></a> const指针</h5><p><strong>常量指针</strong>(<code>const pointer</code>)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针的地址)就不能改变了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumber = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumber;</span><br></pre></td></tr></table></figure><p>弄清这些声明的含义最有效的方法就是从右向左读。</p><h4 id="顶层const"><a class="markdownIt-Anchor" href="#顶层const"></a> 顶层const</h4><p>用名词<strong>顶层const</strong>(<code>top-level const</code>)表示指针本身是个常量，用名词<strong>底层const</strong>(<code>low-level const</code>)表示指针所指的对象是一个常量。</p><p>执行拷贝操作的时候，顶层const不受影响。但是底层const的限制不能忽视，拷入和拷出的对象必须具有相同的底层const资格或者两个对象的数据类型能够转换，一般来说非常量能够转换成常量。</p><h4 id="constexpr和常量表达式"><a class="markdownIt-Anchor" href="#constexpr和常量表达式"></a> constexpr和常量表达式</h4><p><strong>常量表达式</strong>(<code>const expression</code>)是指值不会改变并且在编译过程就能得到计算结果的表达式。</p><blockquote><p>一个对象(或表达式)是否是常量表达式由它的数据类型和初始值共同决定。</p></blockquote><h5 id="constexpr变量"><a class="markdownIt-Anchor" href="#constexpr变量"></a> constexpr变量</h5><p>C++11规定允许将变量声明为<strong>constexpr</strong>类型以便编译器来验证变量的值是否是一个常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">// 只有size是一个constexpr函数时正确</span></span><br></pre></td></tr></table></figure><h5 id="字面值类型"><a class="markdownIt-Anchor" href="#字面值类型"></a> 字面值类型</h5><p>常量表达式的值在编译时就得到计算，所以用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就将它们称为“字面值类型”(literal type)。</p><p>目前，算术类型、引用和指针都属于字面值类型。</p><p>尽管指针和引用能够定义为constexpr，但他们的初始值受到严格限制。<code>一个constexpr指针的初始值必须是nullptr或者0，或者是储存于某个固定地址的对象</code>(全局或者static，引用限制为后者)。</p><h5 id="指针和constexpr"><a class="markdownIt-Anchor" href="#指针和constexpr"></a> 指针和constexpr</h5><blockquote><p>在constexpr声明中定义一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。(顶层const)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// 指向整数常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// 指向整数的常量指针</span></span><br></pre></td></tr></table></figure><h3 id="处理类型"><a class="markdownIt-Anchor" href="#处理类型"></a> 处理类型</h3><h4 id="类型别名type-alias"><a class="markdownIt-Anchor" href="#类型别名type-alias"></a> 类型别名(type alias)</h4><h5 id="typedef"><a class="markdownIt-Anchor" href="#typedef"></a> typedef</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure><h5 id="别名声明alias-declaration"><a class="markdownIt-Anchor" href="#别名声明alias-declaration"></a> 别名声明(alias declaration)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> myint = <span class="type">int</span> *;<span class="comment">// myint是int*的同义词</span></span><br></pre></td></tr></table></figure><h5 id="指针-常量和类型别名"><a class="markdownIt-Anchor" href="#指针-常量和类型别名"></a> 指针、常量和类型别名</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">// cstr是一个指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps;<span class="comment">// ps是一个指针，它的对象是指向char的常量指针</span></span><br></pre></td></tr></table></figure><p>const是对给定类型的修饰，声明语句中用到pstring时，<code>其基本类型是指针</code>。</p><h4 id="auto类型说明符"><a class="markdownIt-Anchor" href="#auto类型说明符"></a> auto类型说明符</h4><p>auto让编译器通过初始值来推算变量的类型，所以显然，auto定义的类型必须要有初始值。</p><p>因为一条声明语句只能有一个基本数据类型，所以该语句的所有变量的初始值类型都必须一样。</p><h5 id="复合类型-常量和auto"><a class="markdownIt-Anchor" href="#复合类型-常量和auto"></a> 复合类型、常量和auto</h5><blockquote><p>引用作为初始值时，真正参与初始化的是引用对象的值，所以编译器会使用引用对象的类型作为auto的类型，而不是引用。</p></blockquote><blockquote><p>auto一般会忽略掉顶层const，同时底层const则会保留下来。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> a = ci;</span><br><span class="line"><span class="keyword">auto</span> b = cr;<span class="comment">// 都是整数</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;i;<span class="comment">// 整型指针</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;ci;<span class="comment">// 指向整数常量的指针(对常量对象取地址是一种底层const)</span></span><br></pre></td></tr></table></figure><p>可以明确指出顶层const</p><blockquote><p>设置一个类型为auto的引用时，初始值的顶层常量属性保留</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;e = ci;<span class="comment">// 整型常量引用</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;f = <span class="number">42</span>;<span class="comment">// 为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符"><a class="markdownIt-Anchor" href="#decltype类型指示符"></a> decltype类型指示符</h4><blockquote><p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">// const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = <span class="number">0</span>;<span class="comment">// const int &amp;</span></span><br></pre></td></tr></table></figure><h5 id="decltype和引用"><a class="markdownIt-Anchor" href="#decltype和引用"></a> decltype和引用</h5><p>decltype使用的表达式不是一个变量，则返回表达式对应的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;<span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给该对象赋值。</p></blockquote><blockquote><p>如果给变量加上了一层或多层括号，编译器就会把它当作一个表达式，变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype会得到引用类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// 错误，int&amp;,引用需要初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;<span class="comment">// int</span></span><br></pre></td></tr></table></figure><h3 id="自定义数据结构"><a class="markdownIt-Anchor" href="#自定义数据结构"></a> 自定义数据结构</h3><p>C++11规定，可以为数据成员提供一个类内初始值，<code>不能使用圆括号</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val1 = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> val2 = &#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="type">int</span> val3&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>预处理变量无视C++关于作用域的规则(即使在函数中定义并且没调用，后续(物理后续即后面行的)的代码也依然视其已定义)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Cpp Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown加粗失效</title>
      <link href="/posts/885d662c.html"/>
      <url>/posts/885d662c.html</url>
      
        <content type="html"><![CDATA[<p>今天用markdown给链接加粗的时候出现了在Typora能正常显示，但是上传到博客就不能正常显示的问题，于是去查找了相关问题，现总结和记录一下。</p><p>markdown用*或者_给内容进行斜体或者加粗的操作，不过需要注意的是并不是可以随意加的，其实markdown是有<a href="https://spec.commonmark.org/0.30/#right-flanking-delimiter-run">规定</a>的。</p><p>简单来说就是*和_被分为左侧定界符序列和右侧定界符序列，判断如下</p><h4 id="左侧定界符序列"><a class="markdownIt-Anchor" href="#左侧定界符序列"></a> 左侧定界符序列</h4><ul><li>后面不能是空白</li><li>前面没有空白或者标点符号的时候，后面不能是标点符号</li></ul><h4 id="右侧定界符序列"><a class="markdownIt-Anchor" href="#右侧定界符序列"></a> 右侧定界符序列</h4><ul><li>前面不能是空白</li><li>后面没有空白或者标点符号的时候，前面不能是标点符号</li></ul><p>当**是左侧定界符序列的时候表示开始粗体，相对的右侧定界符序列表示结束粗体。</p><p>于是就可以发现问题所在了</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">错误示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla<span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span>blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla**<a href="www.example.com">示例</a>**blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>两侧定界符序列都不满足条件，所以需要在左侧前加右侧后各加一个空格。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正确示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla <span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span> blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla <strong><a href="www.example.com">示例</a></strong> blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>但这样会导致渲染之后左右有多的空格，有一个解决方法就是使用零宽字符(<code>Zero Width Space</code>),实体名称<code>&amp;ZeroWidthSpace;</code>,Unicode为U+200B，这个字符不算做空白字符，空白字符是指<a href="https://www.compart.com/en/unicode/category/Zs#UNC_CAT">Zs</a>类的17个字符，所以可以这样更改</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正确示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla&amp;#x200B;<span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span>&amp;#x200B;blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla​<strong><a href="www.example.com">示例</a></strong>​blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>讲道理的话，零宽字符加在左侧*后面右侧*前面应该也是可行的，毕竟他不算是标点字符，不过博客不能正常显示，可能是&amp;的问题，但直接复制放在那个位置的话倒是能在csdn上显示成功，github不太行，可能渲染方式不一样还是怎么回事。</p><h4 id="零宽字符其他用途"><a class="markdownIt-Anchor" href="#零宽字符其他用途"></a> 零宽字符其他用途</h4><h5 id="换行"><a class="markdownIt-Anchor" href="#换行"></a> 换行</h5><p>当一行过长的时候荧幕宽度不足以单行显示时，可以使用它来指定换行位置。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正常显示</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>LongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">加入零宽字符</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongLongLongLongLongLongLongLong&amp;#x200B;BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>LongLongLongLongLongLongLongLong​BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h5 id="绕过敏感词检查和创造不可复制的伪链接等"><a class="markdownIt-Anchor" href="#绕过敏感词检查和创造不可复制的伪链接等"></a> 绕过敏感词检查和创造不可复制的伪链接等</h5><h4 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h4><p><a href="https://juejin.cn/post/7064565848421171213">为什么掘金的 Markdown 加粗语法（**……**）有时候不生效？</a></p><p><a href="https://symbl.cc/cn/">SYMBL (◕‿◕)</a></p><p><a href="https://www.compart.com/en/unicode/">Unicode - Compart</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BUAA OO Unit 2 HW8] 第二单元总结</title>
      <link href="/posts/8f38982b.html"/>
      <url>/posts/8f38982b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>第二单元的主题是电梯调度问题，主要是初步学习多线程的编程思想，解决线程交互和线程安全的问题。早就听说第二单元多线程是OO的一座大山，荣文戈老师也说过以后上班遇到的程序基本上全都和多线程挂钩，所以多线程的学习是很关键的，给哪个对象加锁，如何正确且高效地给对象加锁，都是值得思考的问题。</p><p>这一单元的三次作业也是层层递进，逐步实现了电梯维修、加入电梯、限制电梯可达性和限制楼层服务电梯数量等功能。在本次作业中，我也学会了一些比较常用的设计模式如<code>单例模式</code>和<code>观察者模式</code>等，以及经典的并发同步模式<code>生产者-消费者模式</code>，使得整个项目的耦合度更低，代码层次清晰。</p><h2 id="第一次作业"><a class="markdownIt-Anchor" href="#第一次作业"></a> 第一次作业</h2><p>第一次作业为模拟多线程实时电梯系统，实现6部电梯对实时加入的乘客请求做出反应，接到乘客并送到指定位置，需要模拟电梯的上下行、开关门以及乘客的进出。</p><h3 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h3><h4 id="producer-consumer模型"><a class="markdownIt-Anchor" href="#producer-consumer模型"></a> Producer-Consumer模型</h4><p>首先分析需要将哪些类作为线程运行，首先就是<strong>输入</strong>（<code>InputHandler</code>)需要不断读取请求，其次就是<strong>电梯</strong>(<code>Elevator</code>)需要不断反应请求并模拟运行。</p><p>而将这两个线程连接起来的就是<strong>请求</strong>(<code>Request</code>)，所以生产者-消费者模型的结构也很清晰了，<strong>输入</strong>作为生产者，<strong>电梯</strong>作为消费者，在两个之间我们需要一个容器来盛放<strong>请求</strong>，于是设计<strong>请求队列</strong>(<code>RequestTable</code>)作为这个容器，容器有放入请求和取出请求的功能，而之所以容器不作为线程就在于放入和请求这两个动作的发出者不是容器本身(<s>参考自助餐窗口，柜台是固定的</s>)。</p><p>至此，我们可以得到以下的结构</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122000.png" alt="image-20230412192000478" /></p><p>我采用的是所有电梯共用一个<strong>请求队列</strong>的做法，各个电梯自由竞争。</p><h4 id="调度策略"><a class="markdownIt-Anchor" href="#调度策略"></a> 调度策略</h4><p>电梯调度问题没有一个全局最优解，总会有一些情况使得一个算法劣于其他的算法。目前有的与电梯调度调度相关的算法有<code>ALS</code>,<code>LOOK</code>,<code>SCAN</code>等，课程组给出的算法是<code>ALS</code>，但往届学长大多选择的是<code>LOOK</code>算法，并且我也感觉后者实现的难度要相对低一点，所以选择了<code>LOOK</code>算法。</p><p>具体实现过程——</p><ul><li>首先电梯有一个初始的运动方向(建议使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pm1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord">1</span></span></span></span>，实现比booolean类型方便)</li><li>判断是否需要开门<ol><li>电梯内是否有人出电梯</li><li>该楼层是否有人的请求方向和电梯的运动方向一致</li></ol></li><li>判断电梯内是否有人<ul><li>如果有人，那么沿当前方向继续移动一层</li><li>否则，判断请求队列是否为空<ul><li>如果不为空，接着判断当前方向是否有请求<ul><li>如果有请求，那么沿当前方向继续移动一层</li><li>否则，变换方向</li></ul></li><li>否则，判断输入线程是否结束<ul><li>如果结束了，那么结束电梯线程</li><li>否则，进入等待状态</li></ul></li></ul></li></ul></li></ul><p>如上所述，电梯做出的反应有<code>Open</code>，<code>Move</code>，<code>Reverse</code>，<code>Wait</code>，<code>Over</code>5种，可以设计一个<strong>策略类</strong>(<code>strategy</code>)来封装<code>LOOK</code>算法，根据电梯目前的状态给出电梯需要做出的反应，电梯收到后进行相应的动作。这样可以使得电梯运行和判断相分离，电梯本身更加专注于动作，结构层次也更加清晰。</p><h4 id="类图和时序图"><a class="markdownIt-Anchor" href="#类图和时序图"></a> 类图和时序图</h4><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304121753.png" alt="image-20230412211753149" /></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304132843.png" alt="image-20230413112843704" /></p><p>大致流程如上图所示，无论是放入请求还是输入结束，都会使得<strong>请求队列</strong>唤醒<strong>电梯</strong>，而电梯都会根据<strong>策略</strong>来进行下一步动作。</p><h3 id="锁和同步"><a class="markdownIt-Anchor" href="#锁和同步"></a> 锁和同步</h3><p>本次作业采用的是使用<code>synchronized</code>取得对象锁，避免线程安全问题，保证同一时间不会出现两个线程对同一对象写或者读写。</p><p><code>synchronized</code>有三种加锁的方式——</p><ol><li><p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法：作用于当前类的所有实例，进入同步代码前要获得<strong>当前类的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰一个代码块：给指定的类或者对象加锁，在进入同步代码前需要获得指定类或者对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj or example.class)&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>修饰实例方法与在方法内修饰整个代码块取得当前实例的锁类似，而修饰静态方法与在方法内修饰整个代码块取得当前类的锁类似。</p><p>需要注意的是实例的锁与类的锁不同，实例的锁属于这个实例，类的锁属于类(<s>废话</s>)。讲这个的目的就是为了说明，当一个线程访问加锁的静态方法时，另一个进程依然可以访问加锁的实例方法，两者不冲突。当然加锁的方法和不加锁的方法也不会冲突。</p><p>需要加锁的位置就是有多个线程进行读写的共享数据，在本次作业种显然是<strong>请求队列</strong>，有<strong>输入</strong>的写，以及<strong>电梯</strong>的读写，为了保证每次操作的正确性，我们在进行读写之前都要对<strong>请求队列</strong>加锁，保证进行的是原子操作(执行过程不会被打断)。本次作业将<strong>请求队列</strong>内部涉及修改和读取修改变量的方法都加了锁，在外部对需要保证<strong>请求队列</strong>状态的代码块上了锁。</p><p><code>notifyAll</code>的操作只在修改了共享变量之后存在。</p><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><p>部分方法复杂度如下<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304121904.png" alt="image-20230412211904780" /></p><p>主要出在<strong>策略</strong>类中，因为涉及大量的if-else判断以及for循环遍历楼层的请求队列，所以这部分复杂度略高。</p><h3 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h3><h4 id="二次询问"><a class="markdownIt-Anchor" href="#二次询问"></a> 二次询问</h4><p>因为各个电梯共用一个请求队列，并且策略类将询问和执行分开了，所以可能会出现多个电梯在同一个楼层都给出开门的指示，但是显然只有一个电梯会接到人(接人操作上锁，所以不会出现接到同一个人)，其他的电梯就只开门和关门，这样会白白增加耗电量(<s>虽然自由竞争本身会出现多个电梯都向一个请求跑，耗电量巨大</s>)。一种解决方法就是在开门的操作内部，先对请求队列上锁，然后再次询问策略类当前动作是否还应该是开门，如果是才将人取出，进行接下来的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (requestTable) &#123;</span><br><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> scheduler.getAdvice(curFloor,curNum,direction,eleMap.get(curFloor));</span><br><span class="line"><span class="keyword">if</span> (advice != Advice.OPEN) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmpQueue = requestTable.take(curFloor,direction,curNum - curQueue.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电梯反转"><a class="markdownIt-Anchor" href="#电梯反转"></a> 电梯反转</h4><p>在电梯没人判断当前方向上是否有人的时候，不应该包含当前楼层，否则电梯直接沿着当前方向走了，会出现升天或者遁地的情况。</p><h4 id="开门判断"><a class="markdownIt-Anchor" href="#开门判断"></a> 开门判断</h4><p>为了简便，在策略内判断是否有人进入的时候，传入的当前楼层人数包括可能下电梯的人，所以可能因为超载判断为不需要开门，不过没关系，因为如果有人回下电梯的话就一定会开门，在取人的时候减去下去的人数即可。(<s>要是没有二次询问这个操作的话，直接按顺序下人上人不用特意减，可惜删不得</s>)</p><h4 id="hashmap遍历删除"><a class="markdownIt-Anchor" href="#hashmap遍历删除"></a> HashMap遍历删除</h4><p>在从请求队列中取人的时候我使用了如下操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (PersonRequest person : curQueue) &#123;</span><br><span class="line"><span class="keyword">if</span> (curNum + tmpQueue.size() == Tool.capacity) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((person.getToFloor() - curFloor) * direction &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">tmpQueue.add(person);</span><br><span class="line">curQueue.remove(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即一边遍历一边删除，但是运行的时候会出现<code>java.util.ConcurrentModificationException</code>的报错，于是去网上查找了相关资料。</p><p>简单来说就是HashMap内部维护了一个modCount变量，迭代器里维护了一个expectedModCount变量，初始两者相同，每次HashMap移除和新加元素的时候modCount会自增，此时迭代器里的expectedModCount不变，而迭代器遍历的时候会用到nextNode()方法，当两个值不等的时候就会抛出异常。</p><p>基本上JAVA集合类在遍历时不用迭代器进行删除都会报错，这样是为了防止高并发情况下，多个线程同时修改集合导致数据不一致。</p><p>解决方法就是使用迭代器进行遍历和删除，迭代器的删除也会先判断两者值是否相等，然后调用HashMap的removeNode()方法，最后会令<code>expectedModCount=modCount</code>，这样就不会出现错误了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;PersonRequest&gt; it = curQueue.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext() &amp;&amp; curNum + tmpQueue.size() &lt; Tool.capacity) &#123;</span><br><span class="line"><span class="type">PersonRequest</span> <span class="variable">person</span> <span class="operator">=</span> it.next();</span><br><span class="line"><span class="keyword">if</span> ((person.getToFloor() - curFloor) * direction &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">tmpQueue.add(person);</span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用线程安全的currentHashMap替代HashMap，或者在遍历结束后再遍历取出来的列表对请求队列进行删除。</p><h4 id="些许优化"><a class="markdownIt-Anchor" href="#些许优化"></a> 些许优化</h4><p>在研讨课时，有同学提出既然自由竞争会出现1个请求唤醒6部电梯的情况，那么每来一个请求不使用notifyAll而是使用notify就可以减少耗电量，我觉得有道理，不过貌似这样就不像自由竞争了，虽然也和直接分配不同，总的来说还是一个不错的提议。</p><p>其次就是另一个同学提出在电梯取人的时候可以不直接锁整个队列，而是将对应楼层的队列锁住，这样其他楼层的电梯也可以在此时取人，虽然优化可能不是很明显，不过想法很好，显然要是为了正确性锁住整个队列是更好的，比较无脑，为了性能的话就要将需要锁的部分想清楚，不然正确性可能没法保证。</p><h3 id="bug分析"><a class="markdownIt-Anchor" href="#bug分析"></a> Bug分析</h3><p>中测中出现上述有关HashMap删除的错误，强测和互测没有出现Bug，强测得分97.1553，还是比较出乎我的意料，毕竟自由竞争耗电量确实难蚌。</p><h2 id="第二次作业"><a class="markdownIt-Anchor" href="#第二次作业"></a> 第二次作业</h2><p>第二次作业在第一次作业的基础上需要模拟电梯系统扩建和日常维护时乘客的调度，同时电梯增加速度和容量参数。</p><h3 id="架构-2"><a class="markdownIt-Anchor" href="#架构-2"></a> 架构</h3><h4 id="调度器"><a class="markdownIt-Anchor" href="#调度器"></a> 调度器</h4><p>为了实现扩建和维护功能就需要一个统领所有电梯的容器，来记录目前还在运行的电梯，于是设计了<strong>调度器</strong>(<code>Scheduler</code>)，同时由于第一次作业6部电梯一起抢一个请求实在让我挺难受的，所以我决定让<strong>调度器</strong>同时担任分发请求的任务，让每部电梯都有自己的<strong>乘客队列</strong>，于是产生了以下结构<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304131949.png" alt="image-20230413101941994" /></p><p>相比于第一次作业，<strong>输入</strong>得到请求有三种分别是<code>PersonRequest</code>、<code>ElevatorRequest</code>、<code>MaintainRequest</code>，不同的请求处理方式肯定事不同的，于是在哪个部分对请求进行分类就是一个问题，我采用的方式是在<strong>调度器</strong>内进行分类处理，于是<strong>输入</strong>和<strong>请求队列</strong>基本上就不需要改动，然后<strong>电梯</strong>依赖的<strong>请求队列</strong>变成了<strong>乘客队列</strong>也只是相当于换了个名字，总的来说原则就是让每个类的职责清晰明了。</p><h4 id="换乘-线程结束"><a class="markdownIt-Anchor" href="#换乘-线程结束"></a> 换乘 + 线程结束</h4><p>因为维修请求的存在，电梯可能放出没有到达目的地的乘客，所以会出现乘客需要换乘的情况，处理还是比较简单，直接将没有到达目的地的乘客更改出发楼层然后重新丢进<strong>请求队列</strong>即可，<strong>调度器</strong>会将其作为一个新的请求读取并分配。</p><p>但是随之而来就出现了另一个问题，电梯线程在何时结束，之前的结束判断是电梯内没人并且<strong>请求队列</strong>为空且输入结束，但是在本次作业请求来源不再只是<strong>输入</strong>，还可能是换乘的乘客，所以需要改变结束判断。</p><p>可以发现，虽然有换乘但是总的乘客数是不变的，于是可以设计<strong>请求计数</strong>(<code>RequestCount</code>)维护一个count，当<strong>输入</strong>向<strong>请求队列</strong>放入乘客的时候令count+1，当电梯将乘客送到目的地之后令count-1，于是结束判断就变成了输入结束且count=0。</p><p>由于JAVA没有全局变量这个概念，所以可以使用 <strong><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a></strong> 实现全局变量，本次作业<strong>请求队列</strong>和<strong>请求计数</strong>都使用了单例模式(静态变量和方法实现在本次作业也可以，不过两者略有区别，在此不做讨论)。</p><p>有一点需要吐槽的是，课程组给出的<code>PersonRequest</code>不支持修改出发楼层，于是我自己写了一个<code>Person</code>，没什么不同只是为了修改，当然重新实例化一个<code>PersonRequest</code>也是可行的。(<s>不过这个名字有点长，我不是很喜欢</s>)</p><h4 id="类图和时序图-2"><a class="markdownIt-Anchor" href="#类图和时序图-2"></a> 类图和时序图</h4><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304131324.png" alt="image-20230413111324473" /></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304133541.png" alt="image-20230413113541430" /></p><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304133710.png" alt="image-20230413113710867" /></p><p><strong>调度器</strong>的run内部根据<strong>请求队列</strong>的状态判断是结束线程还是等待还是处理请求，if-else语句导致复杂度较高。</p><h3 id="tips-2"><a class="markdownIt-Anchor" href="#tips-2"></a> tips</h3><ul><li>本次作业中每个电梯都有自己的乘客队列，所以不再需要二次询问。</li><li>理论课上讲解了读写锁的使用，能够允许多个线程同时进行读，不过现在jdk版本下synchronized效率也挺高的，也就没进行更改。</li><li>这次作业要采用自由竞争也是可以的，由输入对请求分类然后进行操作即可，不过架构不是很好看就是了，提这个的目的只是觉得我的调度没有用到速度这一参数，自由竞争在这方面还是有一定优势。</li><li>在接到维修指令之后需要立即将电梯从调度器中删除，防止有新的请求放入其中。</li></ul><h3 id="bug分析-2"><a class="markdownIt-Anchor" href="#bug分析-2"></a> Bug分析</h3><p>中测的时候出现了以下bug</p><ul><li><strong>调度器</strong>在<strong>请求队列</strong>中wait，<strong>请求计数</strong>不能直接唤醒，需要先获得<strong>请求队列</strong>的锁(我感觉这一部分我写的比较混乱)</li><li>因为我自己写了<code>Person</code>，但是<strong>调度器</strong>在处理的时候忘记判断了，导致换乘的乘客没有处理，虽然我加了<code>assert</code>，但是运行的时候没加-ea参数，导致没及时发现错误。(<s>值得一提的是课程组貌似也没有这个参数，所以找错还挺麻烦的，不过这是一个好习惯</s>)</li></ul><p>强测没有问题得分95.1183，互测出现了程序无法结束的问题，我找了很久也不知道问题出现在哪。</p><p>分配策略我采用的是纯随机(random)，运气不好的话可能都分到一部电梯去了。</p><h2 id="第三次作业"><a class="markdownIt-Anchor" href="#第三次作业"></a> 第三次作业</h2><p>第三次作业在第二次作业的基础上，限制了电梯的可达性(只能在一些楼层开门服务)和楼层的最多服务电梯数。</p><h3 id="架构-3"><a class="markdownIt-Anchor" href="#架构-3"></a> 架构</h3><p>这次作业的架构没有什么调整，增加的功能都可以放在已有的模块中进行实现，故UML类图和时序图可以参照第二次作业。</p><h3 id="功能实现"><a class="markdownIt-Anchor" href="#功能实现"></a> 功能实现</h3><h4 id="可达性"><a class="markdownIt-Anchor" href="#可达性"></a> 可达性</h4><p>虽然规定了电梯只能在某些楼层开门服务，但在遇到维修的时候也是可以突破这个限制的，所以为了统一性我们不应该让可达性成为电梯的内置属性，而是通过<strong>调度器</strong>分配符合电梯可达性的乘客，让其看上去是满足要求的，实际上电梯都是功能完全的，能够在任意楼层开门。</p><p>那么问题就在<strong>调度器</strong>如何进行分配了，由于可达性的存在可能会出现乘客一趟不能到达目的地的情况，于是很自然的想到给乘客增加一个当前目的地的属性，对于这个属性的选取有很多种考量方法，我采用的和课程组类似——寻找最少换乘次数的策略，然后选择已有请求最少的电梯进行分配。</p><p>首先在<strong>调度器</strong>内维护一个二维数组map[i][j]表示有几部电梯能够从i楼到j楼，每次增加或者删除一个电梯就根据它的可达性对map进行更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateMap</span><span class="params">(<span class="type">int</span> access,<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Tool.minFloor;i &lt;= Tool.maxFloor;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (accessible(access,i)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Tool.minFloor; j &lt;= Tool.maxFloor;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (accessible(access,j)) &#123;</span><br><span class="line">map[i][j] += type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最少换乘次数dis[i][j]的计算可以简单的使用floyd即可，赋初值部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Tool.minFloor;i &lt;= Tool.maxFloor;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Tool.minFloor;j &lt;= Tool.maxFloor;j++) &#123;</span><br><span class="line">dis[i][j] = i == j ? <span class="number">0</span> : map[i][j] != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算完最短路关于选择目的地采用<code>map[from][i] != 0 &amp;&amp; dis[from][i] + dis[i][to] == dis[from][to]</code>判断即可，最后会返回一个可行的目的地，但是正规来讲的话应该返回一个集合，这样后续分配会更加均匀。</p><p>需要注意的是，设置当前目的地后电梯的策略类的判断同向也应该做出相应修改，其次每次请求被<strong>调度器</strong>取出时都会重新规划，而不是规划出总的路线，因为如果路线中的电梯被维修了就需要重新规划，为了简便就每次都算一次。</p><h4 id="楼层限制"><a class="markdownIt-Anchor" href="#楼层限制"></a> 楼层限制</h4><p>本次作业限制一层楼同时只有4个服务(开门)的电梯，2个只接人($set \sube new_set $)的电梯，后者属于前者，因为在我的实现中出去的乘客不会被马上接进来，所以只接人电梯相当于是没有出去的人。</p><h5 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h5><p>实验课上介绍了<strong>Semaphore</strong>(信号量)的使用，锁的存在使得同一时间只有一个线程能够操作这个对象，而如果想要多个线程同时使用的话，就需要信号量了。信号量内部维护了一个计数器存着可以访问的共享资源的数量，线程要想访问共享资源就需要获得信号量，如果计数器大于0则允许访问并将计数器-1，如果计数器等于0则线程进入休眠，当某个线程释放信号量之后休眠的进程会被唤醒并尝试获取信号量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>,<span class="literal">true</span>); <span class="comment">// 信号量总数，是否公平(先到的先获得)</span></span><br><span class="line">semaphore.acquire(); <span class="comment">// 获取信号量</span></span><br><span class="line">semaphore.release(); <span class="comment">// 释放信号量</span></span><br></pre></td></tr></table></figure><p>获得信号量之后一定要释放。</p><h5 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h5><p>有两种限制，所以对每层楼都需要两个信号量记为s1(4,true),s2(2,true)，当电梯需要开门的时候，如果是普通的电梯只需要获得s1即可，而只接人电梯则需要先获得s1再获得s2(顺序好像没关系)，关门的时候再释放相应信号量即可，信号量都放在了<strong>请求计数</strong>中。</p><h3 id="复杂度分析-3"><a class="markdownIt-Anchor" href="#复杂度分析-3"></a> 复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304132246.png" alt="image-20230413172246586" /></p><p>getDispatchGoal是求下一个目的地的部分，内部有挺多的循环嵌套和if-else判断。</p><h3 id="bug分析-3"><a class="markdownIt-Anchor" href="#bug分析-3"></a> Bug分析</h3><p>三次测试都没问题，强测得分95.2392，不过用hhl同学的评测机总会是不是出现线程无法正常结束的情况，通过输出信息发现是有乘客被吃掉了，放入了电梯但是并没有去接他，最后也没有发现是哪出问题了。</p><h2 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h2><ul><li><p>三次作业电梯运行、策略、输入以及请求队列部分原有的代码基本上都不会发生太大改变，主要的变化在于电梯增加维修的能力，调度器更换调度策略还有结束的判断等，不过只要大的框架定了后续的迭代也就比较简单了。可以发现的是后续迭代课程组对没有调度器的自由竞争并不是很友好，如果不在第二次作业进行重构的话，第三次作业需要改动的东西就更多了。不过架构的确定还是蛮看经验的，也不能说某一个架构就一定好，不过还是应该尽量满足<strong>solid</strong>原则。</p></li><li><p>性能方面，我还是为了简单和易于实现起见，牺牲了部分性能，调度采用自由竞争、随机分配和均匀分配，有的同学采用影子电梯(复制所有电梯状态，模拟判断请求的最优分配方式)，听说得分挺高的，不过本来电梯调度就没有全局最优，我认为首要的还是应该保证架构，有了比较好的架构，换一个调度器也不是很麻烦的事，就像荣文戈老师说的，分工好之后要是这个调度不行就换个程序员做调度器。</p></li><li><p>总的来说，相比于第一单元，这一单元感觉架构更加清晰，各个模块耦合度不高，功能也相对清晰，更有面向对象的感觉。不过这次作业还是留下了一点遗憾，就是第二三次作业的bug还是没找出来，这也让我感到多线程的艰难。</p></li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://hyggge.github.io/2022/04/29/oo/oo-di-er-dan-yuan-zong-jie/">「BUAA-OO」第二单元:电梯调度 | Hyggge’s Blog</a></p><p><a href="https://www.cnblogs.com/saltyfishyjk/p/16218001.html#plantuml%E7%BB%98%E5%9B%BE">「BUAA OO Unit 2 HW8」第二单元总结 - 被水淹没的一条鱼</a></p><p><a href="https://blog.csdn.net/qq_41082953/article/details/120056344">HashMap遍历的时候使用map.remove会报错</a></p><p><a href="https://javastack.blog.csdn.net/article/details/129434123">为什么 HashMap 不能一边遍历一边删除？</a></p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> JAVA </tag>
            
            <tag> 电梯调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvim-配置</title>
      <link href="/posts/1ce0a0b5.html"/>
      <url>/posts/1ce0a0b5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在配置nvim插件的时候遇到了很多的问题，现在记录下来防止以后重复工作，整个配置放在了<a href="https://github.com/Makima777/nvim">Makima777/nvim (github.com)</a>,其中大部分是根据彭启阳同学在OS课程分享的配置更改的。</p><h2 id="1-nvim-treesitter"><a class="markdownIt-Anchor" href="#1-nvim-treesitter"></a> 1. nvim-treesitter</h2><p><a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter</a>是一款具有<strong>代码高亮</strong>，<strong>增量选择</strong>，<strong>代码格式化</strong>以及<strong>折叠代码块</strong>的功能，后面三个我暂时还没用上。</p><p>在安装语言解析器(parser)的时候，对于<code>yaml</code>和<code>html</code>两种语言的时候一直出现错误，报错信息大概是<code>Impossible to load parser for html: Failed to load parser</code>。</p><p>后面在<a href="https://github.com/nvim-treesitter/nvim-treesitter/issues/3587">issue</a>里面找到了相似的问题，原因就是这两种语言在解析器里会使用c++，需要c<ins>的标准库，然后nvim自带的libstdc</ins>-6.dll和gcc的冲突，解决方法就是改变编译器,<code>zig</code>或者<code>clang</code>都可以。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;nvim-treesitter.install&#x27;</span>).compilers = &#123;<span class="string">&quot;zig&quot;</span>, <span class="string">&quot;gcc&quot;</span>, <span class="string">&quot;clang&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-内置终端"><a class="markdownIt-Anchor" href="#2-内置终端"></a> 2. 内置终端</h2><p>在Windows下nvim的内置终端选择的是cmd，用着很不舒服，可以通过以下命令将其改成powershell。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell = vim.fn.executable <span class="string">&quot;pwsh&quot;</span> == <span class="number">1</span> <span class="keyword">and</span> <span class="string">&quot;pwsh&quot;</span> <span class="keyword">or</span> <span class="string">&quot;powershell&quot;</span>,</span><br><span class="line">shellcmdflag = <span class="string">&quot;-NoLogo -NoProfile -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;&quot;</span>,</span><br><span class="line">shellredir = <span class="string">&quot;-RedirectStandardOutput %s -NoNewWindow -Wait&quot;</span>,</span><br><span class="line">shellpipe = <span class="string">&quot;2&gt;&amp;1 | Out-File -Encoding UTF8 %s; exit $LastExitCode&quot;</span>,</span><br><span class="line">shellquote = <span class="string">&quot;&quot;</span>,</span><br><span class="line">shellxquote = <span class="string">&quot;&quot;</span>,</span><br></pre></td></tr></table></figure><h2 id="3-nvim-tree"><a class="markdownIt-Anchor" href="#3-nvim-tree"></a> 3. nvim-tree</h2><p><a href="https://github.com/nvim-tree/nvim-tree.lua">nvim-tree</a>是一款文件管理的插件，可以显示git等信息。</p><p>但是在文件排序的时候默认会根据字典序排，如果遇到数字的话就会出现<code>1,10,2</code>这样的顺序，根据<a href="https://github.com/nvim-tree/nvim-tree.lua/discussions/1896">issue</a>配置就可以解决这个问题了。</p><h2 id="4-code_runner"><a class="markdownIt-Anchor" href="#4-code_runner"></a> 4. code_runner</h2><p><a href="https://github.com/CRAG666/code_runner.nvim">code_runner</a>是一款快速运行文件或者项目的插件，通过参数设置可以配置对应文件或者项目的运行命令。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filetype = &#123;</span><br><span class="line">    c = <span class="string">&#x27;cd %:p:h &amp;&amp; gcc -g -Wall -lm -std=c11 % -o .\\bin\\$fileNameWithoutExt &amp;&amp; .\\bin\\$fileNameWithoutExt&#x27;</span>,</span><br><span class="line">    cpp = <span class="string">&#x27;cd %:p:h &amp;&amp; g++ -g -O2 -Wall -lm -std=c++17 % -o .\\bin\\$fileNameWithoutExt &amp;&amp; .\\bin\\$fileNameWithoutExt&#x27;</span>,</span><br><span class="line">    lua = <span class="string">&#x27;lua&#x27;</span>,</span><br><span class="line">    python = <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    sh = <span class="string">&#x27;bash&#x27;</span>,</span><br><span class="line">    dosbatch = <span class="string">&#x27;cd $dir &amp;&amp; %&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我目前只需要单文件的运行，所以并不是很复杂，其中带<code>$</code>的参数都是code_runner的内置变量，<code>dir</code>代表打开文件的目录，<code>fileName</code>代表文件名，<code>file</code>代表文件路径，<code>fileNameWithoutExt</code>代表没有后缀的文件名。<code>%</code>等是vim的内置变量，详见<a href="https://vimdoc.sourceforge.net/htmldoc/cmdline.html#filename-modifiers">vim 文档</a>。需要注意的是如果不使用code_runner的内置变量那么命令最后会自己加上文件名。</p>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> nvim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-hexo</title>
      <link href="/posts/b68a7456.html"/>
      <url>/posts/b68a7456.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>本文记录Hexo博客搭建过程中的修改配置，主要基于<a href="https://github.com/fomalhaut1998/hexo-theme-Fomalhaut">Fomalhaut</a>大佬分享的配置进行修改。</p><h2 id="front-matter"><a class="markdownIt-Anchor" href="#front-matter"></a> Front-matter</h2><p><code>Front-matter</code> 是 markdown 文件最上方以<code>---</code>分隔的区域，用于指定个别档案的变数。</p><h3 id="page-front-matter-页面配置"><a class="markdownIt-Anchor" href="#page-front-matter-页面配置"></a> Page Front-matter 页面配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>title</td><td style="text-align:center">[必需]页面标题</td></tr><tr><td>date</td><td style="text-align:center">[必需]页面创建时间</td></tr><tr><td>updated</td><td style="text-align:center">[可选]页面更新日期</td></tr><tr><td>type</td><td style="text-align:center">[必需]标签、分类以及友情链接三个页面需要配置</td></tr><tr><td>comments</td><td style="text-align:center">[可选]显示页面评论模块(默认 true)</td></tr><tr><td>description</td><td style="text-align:center">[可选]页面描述</td></tr><tr><td>keywords</td><td style="text-align:center">[可选]页面关键词</td></tr><tr><td>top_img</td><td style="text-align:center">[可选]页面顶部图片</td></tr><tr><td>mathjax</td><td style="text-align:center">[可选]显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td style="text-align:center">[可选]显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td style="text-align:center">[可选]显示侧边栏(默认 true)</td></tr><tr><td>aplayer</td><td style="text-align:center">[可选]在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td style="text-align:center">[可选]配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置,我设置为 true)</td></tr></tbody></table><h3 id="post-front-matter"><a class="markdownIt-Anchor" href="#post-front-matter"></a> Post Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">aside:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>title</td><td style="text-align:center">[必需]文章标题</td></tr><tr><td>date</td><td style="text-align:center">[必需]文章创建时间</td></tr><tr><td>updated</td><td style="text-align:center">[可选]文章更新日期</td></tr><tr><td>tags</td><td style="text-align:center">[可选]文章标签</td></tr><tr><td>categories</td><td style="text-align:center">[可选]文章分类</td></tr><tr><td>keywords</td><td style="text-align:center">[可选]文章关键词</td></tr><tr><td>description</td><td style="text-align:center">[可选]文章描述</td></tr><tr><td>top_img</td><td style="text-align:center">[可选]文章顶部图片</td></tr><tr><td>comments</td><td style="text-align:center">[可选]显示文章评论模块(默认 true)</td></tr><tr><td>cover</td><td style="text-align:center">[可选]文章缩略图</td></tr><tr><td>toc</td><td style="text-align:center">[可选]显示文章TOC(默认为设置中toc的enable配置,我设置为 true)</td></tr><tr><td>toc_number</td><td style="text-align:center">[可选]显示toc_number(默认为设置中toc的number配置,我设置为 true)</td></tr><tr><td>toc_style_simple</td><td style="text-align:center">[可选]显示 toc 简洁模式</td></tr><tr><td>copyright</td><td style="text-align:center">[可选]显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td style="text-align:center">[可选]文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td style="text-align:center">[可选]文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td style="text-align:center">[可选]文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td style="text-align:center">[可选]文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td style="text-align:center">[可选]显示mathjax(当设置mathjax的per_page: false时，才需要配置,默认 false)</td></tr><tr><td>katex</td><td style="text-align:center">[可选]显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td style="text-align:center">[可选]显示侧边栏(默认 true)</td></tr><tr><td>aplayer</td><td style="text-align:center">[可选]在需要的文章加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td style="text-align:center">[可选]配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h2 id="图床设置"><a class="markdownIt-Anchor" href="#图床设置"></a> 图床设置</h2><h3 id="github-picgo-typora"><a class="markdownIt-Anchor" href="#github-picgo-typora"></a> Github + PicGo + typora</h3><p>在github中新建一个仓库作为图床，使用typora插入图片的时候可以通过<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>上传到github中。</p><h3 id="picgo"><a class="markdownIt-Anchor" href="#picgo"></a> PicGo</h3><p>具体配置部分，勾选需要显示的图床(默认全部显示)<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304123035.png" alt="image-20230412113035788" /></p><p>在图床设置内选中相应的图床进行设置</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122929.png" alt="image-20230412112929180" /></p><p>其中图床配置名随意，仓库名按照 github用户名/创建的仓库名 的格式填入即可，分支名输入仓库默认分支即可，Token需要创建，在github页面点击右上角头像<code>Settings-&gt;Developer settings-&gt;personal access tokens-&gt;token(classic)</code>，然后点击<code>Generate new token(classic)</code></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122840.png" alt="image-20230412112840083" /></p><p>Note随意，Expiration有效期选择No expiration(有效期过了之后似乎是需要续期的，嫌麻烦的话直接不设就行），需要注意的是生成之后token只会显示一次，需要复制下来填入上面显示的空里面。</p><p>储存路径就是在图片在仓库中的储存位置，例如img/就会在存在img文件夹内。</p><p>自定义域名我暂时还没用到，如果访问github很慢的话可能需要设置。</p><h3 id="typora"><a class="markdownIt-Anchor" href="#typora"></a> typora</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122705.png" alt="image-20230412112705624" /></p><p>在<code>偏好设置-&gt;图像</code>中如上图设置即可，优先使用相对路径需要取消勾选，PicGo路径选择自己的安装路径即可，通过验证图片上传选项可以测试自己是否配置成功。</p><h3 id="picgo插件"><a class="markdownIt-Anchor" href="#picgo插件"></a> PicGo插件</h3><p>PicGo提供了很多优秀的插件，可以在<code>插件设置</code>中进行搜索安装。</p><h4 id="github-plus"><a class="markdownIt-Anchor" href="#github-plus"></a> github-plus</h4><p>在使用的时候会发现，光是在PicGo的相册中删除图片，github中储存的图片并不会消失，于是可以安装<a href="https://github.com/zWingz/picgo-plugin-github-plus">github-plus</a>插件，对操作进行同步，同时能够把远端的图片pull到相册中。</p><p>安装之后在PicGo设置中勾选githubPlus，然后设置和之前一样即可，token如果忘记了可以去设置中打开<code>配置文件</code>,里面记录了token复制即可(<s>虽然不知道这样真的有安全性吗，还有就是这个插件的token不会隐藏</s>)，接着需要将这个图床设置为默认图床，否则上传还是之前的github设置，即使取消勾选了。</p><p>这个插件还有一个比较好的地方就是他还支持gitee，只需要在origin那一个设置中选择即可。</p><h4 id="super-prefix"><a class="markdownIt-Anchor" href="#super-prefix"></a> super-prefix</h4><p>这一款<a href="https://github.com/gclove/picgo-plugin-super-prefix">插件</a>是用于图片命名的，安装之后可以进行设置</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304123332.png" alt="image-20230412113332495" /></p><p>文件名个性前缀就是设置图片的储存路径，例如图片名为202304123332，那么就会被储存在2023/04/12这个文件夹下，相当于按日期分类了，使用这个需要关掉PicGo的时间戳重命名。</p><p>目前我还没试过除了日期还能不能用其他的命名。</p><h2 id="评论"><a class="markdownIt-Anchor" href="#评论"></a> 评论</h2><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>在<code>_config.butterfly.yml</code>中找到以下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Twikoo</span> <span class="comment"># Valine,Disqus,...</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>use</td><td>使用的评论(最多支持两个)<br>注意:不能同时使用<code>Disqus</code>和<code>Disqusjs</code>，因为它们共用一个ID</td></tr><tr><td>text</td><td>显示评论服务商的名字</td></tr><tr><td>lazyload</td><td>开启后只有滚动到评论位置才会加载评论所需要的资源(开启后评论数将不显示)</td></tr><tr><td>count</td><td>是否在文章顶部显示评论数<br><code>livere</code>、<code>Giscus</code>和<code>utterances</code>不支持评论数显示</td></tr><tr><td>card_post_count</td><td>是都在首页文章卡片显示评论数<br><code>gitalk</code>和上述3种不支持评论数显示</td></tr></tbody></table><h3 id="twikoo-vercel部署"><a class="markdownIt-Anchor" href="#twikoo-vercel部署"></a> Twikoo + Vercel部署</h3><p><a href="https://twikoo.js.org/quick-start.html#vercel-%E9%83%A8%E7%BD%B2">官方文档</a></p><h4 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h4><ol><li><p>申请<a href="https://www.mongodb.com/cloud/atlas/register">MongoDB</a>账号(可以使用谷歌账号进行登录)</p></li><li><p>创建免费<code>MongoDB</code>数据库，区域推荐选择<code>AWS / N. Virginia (us-east-1)</code></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304232250.png" alt="image-20230423152243749" /></p><p>点击<code>Build a Database</code></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304232427.png" alt="image-20230423152426906" /></p><p>选好配置之后点击<code>Create</code></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304232815.png" alt="image-20230423152815187" /></p><p>设置用户名以及密码</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304233241.png" alt="image-20230423153241034" /></p><p>添加所有IP的连接(0.0.0.0/0)，(<a href="https://vercel.com/guides/how-to-allowlist-deployment-ip-address">因为Vercel部署采用动态IP</a>)，完成后点击<code>Fnish and Close</code>。</p></li><li><p>申请Vercel账号(使用邮箱注册并关联到自己的Github)</p></li><li><p>在 Clusters 页面点击 <code>Connect</code>，选择<code>Drivers</code>，记录数据库连接字符串，并将连接字符串中的<code>&lt;password&gt;</code>修改为第2步中数据库密码，留着备用(将在第6步中用到)。</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304234216.png" alt="image-20230423154216844" /></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304234239.png" alt="image-20230423154239848" /></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304234533.png" alt="image-20230423154533032" /></p></li><li><p>点击<a href="https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/main/src/server/vercel-min">链接</a>将Twikoo一键部署到Vercel</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304235348.png" alt="image-20230423155348396" /></p><p>选择Github账号，输入仓库名点击<code>Create</code>，等待部署完成后可见如下效果</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304235547.png" alt="image-20230423155547043" /></p></li><li><p>在Vercel进入创建的仓库，进入<code>Settings-&gt;Environment Variables</code>，添加环境变量Key为<code>MONGODB_URI</code>，Value为第4步中替换password后的字符串，点击<code>Save</code>。</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304232053.png" alt="image-20230423162046044" /></p></li><li><p>进入<code>Deployments</code>，点击<code>Redeploy</code></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304234156.png" alt="image-20230423164156470" /></p><p>重新部署完成之后可以看见以下效果:<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/23/202304234402.png" alt="image-20230423164402689" /></p></li><li><p>其中<code>DOMAINS</code>下的链接(<a href="https://xxx.vercel.app">https://xxx.vercel.app</a>)即为环境id，在主题配置<code>_config.butterfly.yml</code>中填入相关信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># Twikoo</span></span><br><span class="line"><span class="comment"># https://github.com/imaegoo/twikoo</span></span><br><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">https://xxx.vercel.app</span></span><br><span class="line">  <span class="attr">region:</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>envID</td><td>环境id</td></tr><tr><td>region</td><td>环境地域，默认为ap-shanghai，如果不是上海需要传参</td></tr><tr><td>visitor</td><td>是否显示文章阅读数</td></tr><tr><td>option</td><td>可选配置</td></tr></tbody></table><blockquote><p>visitor开启后访问人数将由Twikoo提供，而不是不蒜子。</p></blockquote></li><li><p>接着hexo三连即可看见评论区了。</p></li><li><p>通过右下角的齿轮可以进行管理设置。</p></li></ol><h2 id="参考以及好看的主题收录"><a class="markdownIt-Anchor" href="#参考以及好看的主题收录"></a> 参考以及好看的主题收录</h2><p><a href="https://www.fomal.cc/">Fomalhaut🥝</a></p><p><a href="https://github.com/hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next">hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next</a></p><p><a href="https://tzy1997.com/">唐志远の博客 (tzy1997.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BUAA OO Unit 1 HW4] 第一单元总结</title>
      <link href="/posts/a1dc732f.html"/>
      <url>/posts/a1dc732f.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>第一单元的主题是表达式括号展开化简，初步体会面向对象的思想，学习使用类管理数据，分工协作的行为设计等。该单元一共有三次作业层层递进，逐步实现括号嵌套，自定义函数，三角函数和求导等功能。</p><h2 id="第一次作业"><a class="markdownIt-Anchor" href="#第一次作业"></a> 第一次作业</h2><p>第一次作业为多变量表达式括号展开，运算分为加、减、乘和乘方四种，括号深度至多为一层，UML类图如下图所示</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120229.png" alt="image-20230318195545580" /></p><h3 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h3><p>通过形式化表达可知表达式遵循<code>expr-&gt;term-&gt;factor</code>的结构，通过递归下降算法可以将这些部分给解析出来，和正则表达式相比支持迭代。</p><p>不难发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>r</mi><mo>=</mo><mo>∑</mo><mi>c</mi><mi>o</mi><mi>e</mi><mo>∗</mo><msup><mi>x</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>X</mi></mrow></msup><mo>∗</mo><msup><mi>y</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>Y</mi></mrow></msup><mo>∗</mo><msup><mi>z</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>Z</mi></mrow></msup></mrow><annotation encoding="application/x-tex">expr = \sum coe*x^{expX}*y^{expY}*z^{expZ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">Z</span></span></span></span></span></span></span></span></span></span></span></span>,其实无论是factor或者term都可以表示成上述式子，于是为了可以将其统一成<code>Operator</code>类进行计算。同时为了便于同类项的合并，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>X</mi></mrow></msup><mo>∗</mo><msup><mi>y</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>Y</mi></mrow></msup><mo>∗</mo><msup><mi>z</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>Z</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{expX}*y^{expY}*z^{expZ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">Z</span></span></span></span></span></span></span></span></span></span></span></span> 封装成<code>Unit</code>类，<code>Operator</code>采用HashMap进行储存，其中key为<code>Unit</code>，value为<code>coe</code>。</p><p>本次作业的因子<code>Pow</code>和<code>Number</code>都继承<code>Operator</code>类，<code>Parse</code>类中方法的返回值都为<code>Operator</code>，于是对于<code>Operator</code>来说只需要实现加法和乘法即可，同类项合并以及括号展开都是在这个过程中实现的。</p><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><p>本次作业部分方法复杂度如下，其余方法复杂度较低</p><ul><li>CogC:认知复杂度，代码被阅读和理解的复杂程度</li><li>ev(G):衡量程序非结构化程度</li><li>iv(G):衡量模块判定结构即模块和其他模块的调用关系，模块设计复杂度高意味着模块耦合度高</li><li>v(G):衡量模块判定结构复杂度，数量上表现为独立路径的条数(与循环以及条件语句有关)，圈复杂度大会导致难以测试和维护</li></ul><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120452.png" alt="image-20230316201823884" /></p><p>总的复杂度不算太高，对于<code>Operator</code>的<code>toString</code>方法因为需要选出一个正项先输出，就导致需要额外一次对HashMap的遍历，其实也不是很有必要。</p><h3 id="bug分析"><a class="markdownIt-Anchor" href="#bug分析"></a> Bug分析</h3><p>中测出现以下错误</p><ul><li>解析数字因子的时候忘记还有符号了</li><li>在解析指数之后没有进行<code>lexer.next()</code>的操作</li><li><code>isConstant</code>方法将其中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">expZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">expX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 了，导致会将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>z</mi><mi>y</mi></msup></mrow><annotation encoding="application/x-tex">z^y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span> 判断为不含未知数</li></ul><p>强测和互测没有出现bug</p><h3 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h3><ul><li>HashMap以类作为键值通常判断相等是基于两个类的地址来说，也就是是否是同一个实例，所以想要通过内部元素判断相等就得重写hashcode和equal函数，判断过程为如果hashcode不等为不等，否则通过equal函数判断，所以hashcode作为基础判断只需要保证构造的函数使得相等对象hashcode相同即可，想要简单的话也可以返回统一值跳过这一判断。</li><li>预处理将空白符去掉，<code>**</code>变成<code>^</code>方便判断</li><li>对于连续的±号并未提前处理，对于项之前的符号用sign传入<code>parseTerm</code>方法中，对于数字则是在<code>parseFactor</code>中进行处理</li><li>优化：<ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x**2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord">2</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x*x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li><li>将正的项先输出</li><li>对于系数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pm1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord">1</span></span></span></span>且含有未知数因子的项不输出1</li></ol></li></ul><h2 id="第二次作业"><a class="markdownIt-Anchor" href="#第二次作业"></a> 第二次作业</h2><p>第二次作业支持括号嵌套，新增三角函数因子和自定义函数因子，UML类图如下图所示</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120459.png" alt="image-20230318200106301" /></p><h3 id="架构-2"><a class="markdownIt-Anchor" href="#架构-2"></a> 架构</h3><p>对于三角函数的处理，<code>Unit</code>需要表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>X</mi></mrow></msup><mo>∗</mo><msup><mi>y</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>Y</mi></mrow></msup><mo>∗</mo><msup><mi>z</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>Z</mi></mrow></msup><mo>∗</mo><mo>∏</mo><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∏</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x^{expX}*y^{expY}*z^{expZ}*\prod(sin(expr_i))\prod(cos(expr_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">Z</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> ，为了便于输出与合并同样采用HashMap储存三角函数，key值为expr即<code>Operator</code>类，value值为该三角函数的指数部分，新增继承<code>Operator</code>的<code>Sin</code>和<code>Cos</code>类进行构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unit.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Operator, Integer&gt; sinMap;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Operator, Integer&gt; cosMap;</span><br></pre></td></tr></table></figure><p>对于自定义函数的处理，新增<code>Definer</code>类处理自定义函数的定义和调用，所有成员以及方法都是静态的，直接采用类名调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,String&gt; funcMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt; paraMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">funcPattern</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;funcName&gt;[fgh])\\((?&lt;para&gt;.*)\\)=(?&lt;expr&gt;.*)&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">paraPattern</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;para&gt;[xyz]),?&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addFunc</span><span class="params">(String input)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">callFunc</span><span class="params">(String funcName,ArrayList&lt;Operator&gt; actualPara)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>addFunc</code>内部采用正则表达式分割自定义函数各部分。<code>callFunc</code>调用的时候传入的实参是<code>Operator</code>类的，也可以调用它的<code>toString</code>方法传入String类型的数组,具体过程是按字符遍历函数定义式，如果是参数就用对应位置的实参替换(不是在原String替换，而是新建一个StringBuilder)。</p><p>同时新增<code>Function</code>类储存调用之后得到的表达式，同时可以将此表达式解析成<code>Operator</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String expr;</span><br><span class="line"><span class="keyword">public</span> Operator <span class="title function_">expandExpr</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在<code>Parse</code>中新增<code>parseFunction</code>方法，内部使用<code>parseFactor</code>读取实参列表，接着使用<code>callFunc</code>得到新的表达式，再返回<code>expandExpr</code>即可。</p><p>这次调整了一下<code>Parse</code>内部解析因子的方法，将对数字、未知数、三角函数和指数等的解析用方法封装了起来，指数的处理在需要的方法内进行，使得未知数以及三角函数的指数不用通过乘法实现而是直接赋值，总体来说可读性和可维护性提高了。</p><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120513.png" alt="image-20230317103249850" /></p><p>部分方法复杂度如上，<code>Unit</code>中的<code>equals</code>复杂度高是因为采用涉及两个HashMap的相等判断，先用if判断了size其次使用for循环判断元素是否存在映射，主要是sin和cos虽然结构类似但是由于采用两个容器储存，导致不能进行统一处理，结果出现了很多的重复性工作，这一缺点在输出等地方均存在。<code>Operator</code>的<code>equals</code>也是由于HashMap的相等判断。</p><h3 id="bug分析-2"><a class="markdownIt-Anchor" href="#bug分析-2"></a> Bug分析</h3><p>中测</p><ul><li>就像上面说的一样，因为Cos和Sin很多类似的操作，所以复制代码结果导致一些地方没有修改到（<s>复制是坏文明</s></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">cos(0)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li></ul><p>强测和互测</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mn>0</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">sin(0)^0=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li><li>比较表达式相等的时候忘记比较系数了，导致<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sin(x)+sin(2x)=2sin(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></li></ul><p>互测过程中有一个同学没有处理自定义函数中的空白字符(<s>帮我挽回了一点分数</s></p><h3 id="tips-2"><a class="markdownIt-Anchor" href="#tips-2"></a> tips</h3><ul><li>对于函数实参的代入不能直接<code>replaceAll</code>，不然可能将已替换实参中的未知数替换掉，研讨课某些同学提出将<code>xyz</code>换成<code>pqr</code>等没出现的字符(<s>可行不过没有可拓展性</s>)，还有使用java中的<code>MessageFormat</code>类替换的。</li><li>传入实参需要在左右两侧加括号。</li></ul><h2 id="第三次作业"><a class="markdownIt-Anchor" href="#第三次作业"></a> 第三次作业</h2><p>第三次作业新增求导因子，函数定义时可以调用已有函数，函数定义中的求导因子先求导再代入实参,UML类图如下</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120518.png" alt="image-20230318204703578" /></p><h3 id="架构-3"><a class="markdownIt-Anchor" href="#架构-3"></a> 架构</h3><p>这次主要就是在<code>Operator</code>和<code>Unit</code>分别加入求导的方法,通过乘法法则和链式法则等返回新的表达式,需要注意的是<code>Unit</code>采用乘法法则需要深拷贝。</p><p>其次函数在定义的时候先进行解析操作去掉求导因子，于是将解析字符串的操作封装在<code>Definer</code>方法中(<s><code>Function</code>显得更没必要了</s>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Operator <span class="title function_">simplifyExpr</span><span class="params">(String expr)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Lexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lexer</span>(expr);</span><br><span class="line">    <span class="type">Parser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parser</span>(lexer);</span><br><span class="line">    <span class="keyword">return</span> parser.parseExpr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a class="markdownIt-Anchor" href="#复杂度分析-3"></a> 复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120524.png" alt="image-20230317112423675" /></p><p>部分方法复杂度如上，自己比较习惯将一些模块化的部分封装成方法进行调用，所以复杂度看上去还好，不然的话某些方法会很臃肿复杂度可能也会很高，不过也会导致方法很多的问题。</p><h3 id="tips-3"><a class="markdownIt-Anchor" href="#tips-3"></a> tips</h3><ul><li>第二次作业中sin输出内部因子无脑加了层括号，在这一次判断了是否是单因子，减少括号输出，主要有数字，幂函数，三角函数这三种情况，不过由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 会输出为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x*x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，所以需要特判一下。</li></ul><h3 id="bug分析-3"><a class="markdownIt-Anchor" href="#bug分析-3"></a> Bug分析</h3><p>中测</p><ul><li>主要bug就出在上面所说的优化判断，细节没有考虑好</li></ul><p>强测和互测没有bug。</p><h2 id="反思与体会"><a class="markdownIt-Anchor" href="#反思与体会"></a> 反思与体会</h2><ul><li>还是比较面向过程，主打的就是<strong>everything is Operator</strong>，没有将各模块解耦合，都集中在<code>Operator</code>和<code>Unit</code>两个部分，理想的架构应该是先解析出式子，再实现括号展开以及化简，用老师的话来说就是可以将每部分的工作交给不同的程序员来做。</li><li><code>Number</code>等单因子虽然继承了<code>Operator</code>但是实际上没有什么自己的feature，只是为了方便构造或者理解，有些鸡肋。</li><li><code>Unit</code>中指数的部分是用三个数分别储存的，对于后面可能的迭代开发并不是很有利，而且在某些方法中需要进行一个一个判断，应该使用HashMap储存会更加合理。</li><li>作业中对三角函数做过多的优化，只是在构造的时候对sin(0)和cos(0)进行了简单的判断，不过也多亏了是边构造边化简的形式，当然也是架构的问题导致过程中不太能做更多的三角优化，除非最后再进行一次化简。</li><li>三角函数没做统一处理，导致很多重复性的工作，后面再出现其余的三角函数的话，就需要继续同样的操作，应该合并成一个类在里面存有三角函数名。</li><li>这次就只有没测试的第二次作业出问题了(<s>虽然第一次和第三次都是用的大佬的评测机</s>),深深体会到了评测的必要性。</li><li>OO的讨论区有很多大佬分享自己的架构经验以及评测等等，没有思路的时候可以多看看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 表达式化简 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
