<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>markdown加粗失效</title>
      <link href="/posts/885d662c.html"/>
      <url>/posts/885d662c.html</url>
      
        <content type="html"><![CDATA[<p>今天用markdown给链接加粗的时候出现了在Typora能正常显示，但是上传到博客就不能正常显示的问题，于是去查找了相关问题，现总结和记录一下。</p><p>markdown用*或者_给内容进行斜体或者加粗的操作，不过需要注意的是并不是可以随意加的，其实markdown是有<a href="https://spec.commonmark.org/0.30/#right-flanking-delimiter-run">规定</a>的。</p><p>简单来说就是*和_被分为左侧定界符序列和右侧定界符序列，判断如下</p><h4 id="左侧定界符序列"><a href="#左侧定界符序列" class="headerlink" title="左侧定界符序列"></a>左侧定界符序列</h4><ul><li>后面不能是空白</li><li>前面没有空白或者标点符号的时候，后面不能是标点符号</li></ul><h4 id="右侧定界符序列"><a href="#右侧定界符序列" class="headerlink" title="右侧定界符序列"></a>右侧定界符序列</h4><ul><li>前面不能是空白</li><li>后面没有空白或者标点符号的时候，前面不能是标点符号</li></ul><p>当**是左侧定界符序列的时候表示开始粗体，相对的右侧定界符序列表示结束粗体。</p><p>于是就可以发现问题所在了</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">错误示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla<span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span>blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla<strong><a href="www.example.com">示例</a></strong>blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>两侧定界符序列都不满足条件，所以需要在左侧前加右侧后各加一个空格。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正确示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla <span class="strong">**[<span class="string">示例</span>](<span class="link">www.example.com</span>)**</span> blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla <strong><a href="www.example.com">示例</a></strong> blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>但是这样会导致渲染之后左右有多的空格，还有一个解决方法就是使用零宽字符(<code>Zero Width Space</code>),实体名称<code>&amp;ZeroWidthSpace;</code>,Unicode为U+200B，这个字符不算做空白字符，空白字符是指<a href="https://www.compart.com/en/unicode/category/Zs#UNC_CAT">Zs</a>类的17个字符，所以可以这样更改</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正确示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blabla<span class="strong">**&amp;ZeroWidthSpace;[<span class="string">示例</span>](<span class="link">www.example.com</span>)&amp;#x200B;**</span>blabla</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>blabla<strong>&ZeroWidthSpace;<a href="www.example.com">示例</a>&#x200B;</strong>blabla</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>这样就没有标点符号标点符号在**附近了。</p><h4 id="零宽字符其他用途"><a href="#零宽字符其他用途" class="headerlink" title="零宽字符其他用途"></a>零宽字符其他用途</h4><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>当一行过长的时候荧幕宽度不足以单行显示时，可以使用它来指定换行位置。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">正常显示</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>LongLongLongLongLongLongLongLongBreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">加入零宽字符</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LongLongLongLongLongLongLongLong&amp;#x200B;BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>LongLongLongLongLongLongLongLong&#x200B;BreakBeforeHereLongLongLongLongLongLongLongLongLongLongLongLongLongLongText</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h5 id="绕过敏感词检查和创造不可复制的伪链接等"><a href="#绕过敏感词检查和创造不可复制的伪链接等" class="headerlink" title="绕过敏感词检查和创造不可复制的伪链接等"></a>绕过敏感词检查和创造不可复制的伪链接等</h5><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.cn/post/7064565848421171213">为什么掘金的 Markdown 加粗语法（**……**）有时候不生效？</a></p><p><a href="https://symbl.cc/cn/">SYMBL (◕‿◕)</a></p><p><a href="https://www.compart.com/en/unicode/">Unicode - Compart</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BUAA OO Unit 2 HW8] 第二单元总结</title>
      <link href="/posts/8f38982b.html"/>
      <url>/posts/8f38982b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>第二单元的主题是电梯调度问题，主要是初步学习多线程的编程思想，解决线程交互和线程安全的问题。早就听说第二单元多线程是OO的一座大山，荣文戈老师也说过以后上班遇到的程序基本上全都和多线程挂钩，所以多线程的学习是很关键的，给哪个对象加锁，如何正确且高效地给对象加锁，都是值得思考的问题。</p><p>这一单元的三次作业也是层层递进，逐步实现了电梯维修、加入电梯、限制电梯可达性和限制楼层服务电梯数量等功能。在本次作业中，我也学会了一些比较常用的设计模式如<code>单例模式</code>和<code>观察者模式</code>等，以及经典的并发同步模式<code>生产者-消费者模式</code>，使得整个项目的耦合度更低，代码层次清晰。</p><h2 id="第一次作业">第一次作业</h2><p>第一次作业为模拟多线程实时电梯系统，实现6部电梯对实时加入的乘客请求做出反应，接到乘客并送到指定位置，需要模拟电梯的上下行、开关门以及乘客的进出。</p><h3 id="架构">架构</h3><h4 id="Producer-Consumer模型">Producer-Consumer模型</h4><p>首先分析需要将哪些类作为线程运行，首先就是<strong>输入</strong>（<code>InputHandler</code>)需要不断读取请求，其次就是<strong>电梯</strong>(<code>Elevator</code>)需要不断反应请求并模拟运行。</p><p>而将这两个线程连接起来的就是<strong>请求</strong>(<code>Request</code>)，所以生产者-消费者模型的结构也很清晰了，<strong>输入</strong>作为生产者，<strong>电梯</strong>作为消费者，在两个之间我们需要一个容器来盛放<strong>请求</strong>，于是设计<strong>请求队列</strong>(<code>RequestTable</code>)作为这个容器，容器有放入请求和取出请求的功能，而之所以容器不作为线程就在于放入和请求这两个动作的发出者不是容器本身(<s>参考自助餐窗口，柜台是固定的</s>)。</p><p>至此，我们可以得到以下的结构</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122000.png" alt="image-20230412192000478"></p><p>我采用的是所有电梯共用一个<strong>请求队列</strong>的做法，各个电梯自由竞争。</p><h4 id="调度策略">调度策略</h4><p>电梯调度问题没有一个全局最优解，总会有一些情况使得一个算法劣于其他的算法。目前有的与电梯调度调度相关的算法有<code>ALS</code>,<code>LOOK</code>,<code>SCAN</code>等，课程组给出的算法是<code>ALS</code>，但往届学长大多选择的是<code>LOOK</code>算法，并且我也感觉后者实现的难度要相对低一点，所以选择了<code>LOOK</code>算法。</p><p>具体实现过程——</p><ul><li>首先电梯有一个初始的运动方向(建议使用$\pm1$，实现比booolean类型方便)</li><li>判断是否需要开门<ol><li>电梯内是否有人出电梯</li><li>该楼层是否有人的请求方向和电梯的运动方向一致</li></ol></li><li>判断电梯内是否有人<ul><li>如果有人，那么沿当前方向继续移动一层</li><li>否则，判断请求队列是否为空<ul><li>如果不为空，接着判断当前方向是否有请求<ul><li>如果有请求，那么沿当前方向继续移动一层</li><li>否则，变换方向</li></ul></li><li>否则，判断输入线程是否结束<ul><li>如果结束了，那么结束电梯线程</li><li>否则，进入等待状态</li></ul></li></ul></li></ul></li></ul><p>如上所述，电梯做出的反应有<code>Open</code>，<code>Move</code>，<code>Reverse</code>，<code>Wait</code>，<code>Over</code>5种，可以设计一个<strong>策略类</strong>(<code>strategy</code>)来封装<code>LOOK</code>算法，根据电梯目前的状态给出电梯需要做出的反应，电梯收到后进行相应的动作。这样可以使得电梯运行和判断相分离，电梯本身更加专注于动作，结构层次也更加清晰。</p><h4 id="类图和时序图">类图和时序图</h4><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304121753.png" alt="image-20230412211753149"></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304132843.png" alt="image-20230413112843704"></p><p>大致流程如上图所示，无论是放入请求还是输入结束，都会使得<strong>请求队列</strong>唤醒<strong>电梯</strong>，而电梯都会根据<strong>策略</strong>来进行下一步动作。</p><h3 id="锁和同步">锁和同步</h3><p>本次作业采用的是使用<code>synchronized</code>取得对象锁，避免线程安全问题，保证同一时间不会出现两个线程对同一对象写或者读写。</p><p><code>synchronized</code>有三种加锁的方式——</p><ol><li><p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法：作用于当前类的所有实例，进入同步代码前要获得<strong>当前类的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰一个代码块：给指定的类或者对象加锁，在进入同步代码前需要获得指定类或者对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj or example.class)&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>修饰实例方法与在方法内修饰整个代码块取得当前实例的锁类似，而修饰静态方法与在方法内修饰整个代码块取得当前类的锁类似。</p><p>需要注意的是实例的锁与类的锁不同，实例的锁属于这个实例，类的锁属于类(<s>废话</s>)。讲这个的目的就是为了说明，当一个线程访问加锁的静态方法时，另一个进程依然可以访问加锁的实例方法，两者不冲突。当然加锁的方法和不加锁的方法也不会冲突。</p><p>需要加锁的位置就是有多个线程进行读写的共享数据，在本次作业种显然是<strong>请求队列</strong>，有<strong>输入</strong>的写，以及<strong>电梯</strong>的读写，为了保证每次操作的正确性，我们在进行读写之前都要对<strong>请求队列</strong>加锁，保证进行的是原子操作(执行过程不会被打断)。本次作业将<strong>请求队列</strong>内部涉及修改和读取修改变量的方法都加了锁，在外部对需要保证<strong>请求队列</strong>状态的代码块上了锁。</p><p><code>notifyAll</code>的操作只在修改了共享变量之后存在。</p><h3 id="复杂度分析">复杂度分析</h3><p>部分方法复杂度如下<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304121904.png" alt="image-20230412211904780"></p><p>主要出在<strong>策略</strong>类中，因为涉及大量的if-else判断以及for循环遍历楼层的请求队列，所以这部分复杂度略高。</p><h3 id="tips">tips</h3><h4 id="二次询问">二次询问</h4><p>因为各个电梯共用一个请求队列，并且策略类将询问和执行分开了，所以可能会出现多个电梯在同一个楼层都给出开门的指示，但是显然只有一个电梯会接到人(接人操作上锁，所以不会出现接到同一个人)，其他的电梯就只开门和关门，这样会白白增加耗电量(<s>虽然自由竞争本身会出现多个电梯都向一个请求跑，耗电量巨大</s>)。一种解决方法就是在开门的操作内部，先对请求队列上锁，然后再次询问策略类当前动作是否还应该是开门，如果是才将人取出，进行接下来的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (requestTable) &#123;</span><br><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> scheduler.getAdvice(curFloor,curNum,direction,eleMap.get(curFloor));</span><br><span class="line"><span class="keyword">if</span> (advice != Advice.OPEN) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmpQueue = requestTable.take(curFloor,direction,curNum - curQueue.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电梯反转">电梯反转</h4><p>在电梯没人判断当前方向上是否有人的时候，不应该包含当前楼层，否则电梯直接沿着当前方向走了，会出现升天或者遁地的情况。</p><h4 id="开门判断">开门判断</h4><p>为了简便，在策略内判断是否有人进入的时候，传入的当前楼层人数包括可能下电梯的人，所以可能因为超载判断为不需要开门，不过没关系，因为如果有人回下电梯的话就一定会开门，在取人的时候减去下去的人数即可。(<s>要是没有二次询问这个操作的话，直接按顺序下人上人不用特意减，可惜删不得</s>)</p><h4 id="HashMap遍历删除">HashMap遍历删除</h4><p>在从请求队列中取人的时候我使用了如下操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (PersonRequest person : curQueue) &#123;</span><br><span class="line"><span class="keyword">if</span> (curNum + tmpQueue.size() == Tool.capacity) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((person.getToFloor() - curFloor) * direction &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">tmpQueue.add(person);</span><br><span class="line">curQueue.remove(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即一边遍历一边删除，但是运行的时候会出现<code>java.util.ConcurrentModificationException</code>的报错，于是去网上查找了相关资料。</p><p>简单来说就是HashMap内部维护了一个modCount变量，迭代器里维护了一个expectedModCount变量，初始两者相同，每次HashMap移除和新加元素的时候modCount会自增，此时迭代器里的expectedModCount不变，而迭代器遍历的时候会用到nextNode()方法，当两个值不等的时候就会抛出异常。</p><p>基本上JAVA集合类在遍历时不用迭代器进行删除都会报错，这样是为了防止高并发情况下，多个线程同时修改集合导致数据不一致。</p><p>解决方法就是使用迭代器进行遍历和删除，迭代器的删除也会先判断两者值是否相等，然后调用HashMap的removeNode()方法，最后会令<code>expectedModCount=modCount</code>，这样就不会出现错误了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;PersonRequest&gt; it = curQueue.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext() &amp;&amp; curNum + tmpQueue.size() &lt; Tool.capacity) &#123;</span><br><span class="line"><span class="type">PersonRequest</span> <span class="variable">person</span> <span class="operator">=</span> it.next();</span><br><span class="line"><span class="keyword">if</span> ((person.getToFloor() - curFloor) * direction &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">tmpQueue.add(person);</span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用线程安全的currentHashMap替代HashMap，或者在遍历结束后再遍历取出来的列表对请求队列进行删除。</p><h4 id="些许优化">些许优化</h4><p>在研讨课时，有同学提出既然自由竞争会出现1个请求唤醒6部电梯的情况，那么每来一个请求不使用notifyAll而是使用notify就可以减少耗电量，我觉得有道理，不过貌似这样就不像自由竞争了，虽然也和直接分配不同，总的来说还是一个不错的提议。</p><p>其次就是另一个同学提出在电梯取人的时候可以不直接锁整个队列，而是将对应楼层的队列锁住，这样其他楼层的电梯也可以在此时取人，虽然优化可能不是很明显，不过想法很好，显然要是为了正确性锁住整个队列是更好的，比较无脑，为了性能的话就要将需要锁的部分想清楚，不然正确性可能没法保证。</p><h3 id="Bug分析">Bug分析</h3><p>中测中出现上述有关HashMap删除的错误，强测和互测没有出现Bug，强测得分97.1553，还是比较出乎我的意料，毕竟自由竞争耗电量确实难蚌。</p><h2 id="第二次作业">第二次作业</h2><p>第二次作业在第一次作业的基础上需要模拟电梯系统扩建和日常维护时乘客的调度，同时电梯增加速度和容量参数。</p><h3 id="架构-2">架构</h3><h4 id="调度器">调度器</h4><p>为了实现扩建和维护功能就需要一个统领所有电梯的容器，来记录目前还在运行的电梯，于是设计了<strong>调度器</strong>(<code>Scheduler</code>)，同时由于第一次作业6部电梯一起抢一个请求实在让我挺难受的，所以我决定让<strong>调度器</strong>同时担任分发请求的任务，让每部电梯都有自己的<strong>乘客队列</strong>，于是产生了以下结构<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304131949.png" alt="image-20230413101941994"></p><p>相比于第一次作业，<strong>输入</strong>得到请求有三种分别是<code>PersonRequest</code>、<code>ElevatorRequest</code>、<code>MaintainRequest</code>，不同的请求处理方式肯定事不同的，于是在哪个部分对请求进行分类就是一个问题，我采用的方式是在<strong>调度器</strong>内进行分类处理，于是<strong>输入</strong>和<strong>请求队列</strong>基本上就不需要改动，然后<strong>电梯</strong>依赖的<strong>请求队列</strong>变成了<strong>乘客队列</strong>也只是相当于换了个名字，总的来说原则就是让每个类的职责清晰明了。</p><h4 id="换乘-线程结束">换乘 + 线程结束</h4><p>因为维修请求的存在，电梯可能放出没有到达目的地的乘客，所以会出现乘客需要换乘的情况，处理还是比较简单，直接将没有到达目的地的乘客更改出发楼层然后重新丢进<strong>请求队列</strong>即可，<strong>调度器</strong>会将其作为一个新的请求读取并分配。</p><p>但是随之而来就出现了另一个问题，电梯线程在何时结束，之前的结束判断是电梯内没人并且<strong>请求队列</strong>为空且输入结束，但是在本次作业请求来源不再只是<strong>输入</strong>，还可能是换乘的乘客，所以需要改变结束判断。</p><p>可以发现，虽然有换乘但是总的乘客数是不变的，于是可以设计<strong>请求计数</strong>(<code>RequestCount</code>)维护一个count，当<strong>输入</strong>向<strong>请求队列</strong>放入乘客的时候令count+1，当电梯将乘客送到目的地之后令count-1，于是结束判断就变成了输入结束且count=0。</p><p>由于JAVA没有全局变量这个概念，所以可以使用 <strong><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a></strong> 实现全局变量，本次作业<strong>请求队列</strong>和<strong>请求计数</strong>都使用了单例模式(静态变量和方法实现在本次作业也可以，不过两者略有区别，在此不做讨论)。</p><p>有一点需要吐槽的是，课程组给出的<code>PersonRequest</code>不支持修改出发楼层，于是我自己写了一个<code>Person</code>，没什么不同只是为了修改，当然重新实例化一个<code>PersonRequest</code>也是可行的。(<s>不过这个名字有点长，我不是很喜欢</s>)</p><h4 id="类图和时序图-2">类图和时序图</h4><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304131324.png" alt="image-20230413111324473"></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304133541.png" alt="image-20230413113541430"></p><h3 id="复杂度分析-2">复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304133710.png" alt="image-20230413113710867"></p><p><strong>调度器</strong>的run内部根据<strong>请求队列</strong>的状态判断是结束线程还是等待还是处理请求，if-else语句导致复杂度较高。</p><h3 id="tips-2">tips</h3><ul><li>本次作业中每个电梯都有自己的乘客队列，所以不再需要二次询问。</li><li>理论课上讲解了读写锁的使用，能够允许多个线程同时进行读，不过现在jdk版本下synchronized效率也挺高的，也就没进行更改。</li><li>这次作业要采用自由竞争也是可以的，由输入对请求分类然后进行操作即可，不过架构不是很好看就是了，提这个的目的只是觉得我的调度没有用到速度这一参数，自由竞争在这方面还是有一定优势。</li><li>在接到维修指令之后需要立即将电梯从调度器中删除，防止有新的请求放入其中。</li></ul><h3 id="Bug分析-2">Bug分析</h3><p>中测的时候出现了以下bug</p><ul><li><strong>调度器</strong>在<strong>请求队列</strong>中wait，<strong>请求计数</strong>不能直接唤醒，需要先获得<strong>请求队列</strong>的锁(我感觉这一部分我写的比较混乱)</li><li>因为我自己写了<code>Person</code>，但是<strong>调度器</strong>在处理的时候忘记判断了，导致换乘的乘客没有处理，虽然我加了<code>assert</code>，但是运行的时候没加-ea参数，导致没及时发现错误。(<s>值得一提的是课程组貌似也没有这个参数，所以找错还挺麻烦的，不过这是一个好习惯</s>)</li></ul><p>强测没有问题得分95.1183，互测出现了程序无法结束的问题，我找了很久也不知道问题出现在哪。</p><p>分配策略我采用的是纯随机(random)，运气不好的话可能都分到一部电梯去了。</p><h2 id="第三次作业">第三次作业</h2><p>第三次作业在第二次作业的基础上，限制了电梯的可达性(只能在一些楼层开门服务)和楼层的最多服务电梯数。</p><h3 id="架构-3">架构</h3><p>这次作业的架构没有什么调整，增加的功能都可以放在已有的模块中进行实现，故UML类图和时序图可以参照第二次作业。</p><h3 id="功能实现">功能实现</h3><h4 id="可达性">可达性</h4><p>虽然规定了电梯只能在某些楼层开门服务，但在遇到维修的时候也是可以突破这个限制的，所以为了统一性我们不应该让可达性成为电梯的内置属性，而是通过<strong>调度器</strong>分配符合电梯可达性的乘客，让其看上去是满足要求的，实际上电梯都是功能完全的，能够在任意楼层开门。</p><p>那么问题就在<strong>调度器</strong>如何进行分配了，由于可达性的存在可能会出现乘客一趟不能到达目的地的情况，于是很自然的想到给乘客增加一个当前目的地的属性，对于这个属性的选取有很多种考量方法，我采用的和课程组类似——寻找最少换乘次数的策略，然后选择已有请求最少的电梯进行分配。</p><p>首先在<strong>调度器</strong>内维护一个二维数组map[i][j]表示有几部电梯能够从i楼到j楼，每次增加或者删除一个电梯就根据它的可达性对map进行更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateMap</span><span class="params">(<span class="type">int</span> access,<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Tool.minFloor;i &lt;= Tool.maxFloor;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (accessible(access,i)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Tool.minFloor; j &lt;= Tool.maxFloor;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (accessible(access,j)) &#123;</span><br><span class="line">map[i][j] += type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最少换乘次数dis[i][j]的计算可以简单的使用floyd即可，赋初值部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Tool.minFloor;i &lt;= Tool.maxFloor;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Tool.minFloor;j &lt;= Tool.maxFloor;j++) &#123;</span><br><span class="line">dis[i][j] = i == j ? <span class="number">0</span> : map[i][j] != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算完最短路关于选择目的地采用<code>map[from][i] != 0 &amp;&amp; dis[from][i] + dis[i][to] == dis[from][to]</code>判断即可，最后会返回一个可行的目的地，但是正规来讲的话应该返回一个集合，这样后续分配会更加均匀。</p><p>需要注意的是，设置当前目的地后电梯的策略类的判断同向也应该做出相应修改，其次每次请求被<strong>调度器</strong>取出时都会重新规划，而不是规划出总的路线，因为如果路线中的电梯被维修了就需要重新规划，为了简便就每次都算一次。</p><h4 id="楼层限制">楼层限制</h4><p>本次作业限制一层楼同时只有4个服务(开门)的电梯，2个只接人($set \sube new_set $)的电梯，后者属于前者，因为在我的实现中出去的乘客不会被马上接进来，所以只接人电梯相当于是没有出去的人。</p><h5 id="Semaphore">Semaphore</h5><p>实验课上介绍了<strong>Semaphore</strong>(信号量)的使用，锁的存在使得同一时间只有一个线程能够操作这个对象，而如果想要多个线程同时使用的话，就需要信号量了。信号量内部维护了一个计数器存着可以访问的共享资源的数量，线程要想访问共享资源就需要获得信号量，如果计数器大于0则允许访问并将计数器-1，如果计数器等于0则线程进入休眠，当某个线程释放信号量之后休眠的进程会被唤醒并尝试获取信号量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>,<span class="literal">true</span>); <span class="comment">// 信号量总数，是否公平(先到的先获得)</span></span><br><span class="line">semaphore.acquire(); <span class="comment">// 获取信号量</span></span><br><span class="line">semaphore.release(); <span class="comment">// 释放信号量</span></span><br></pre></td></tr></table></figure><p>获得信号量之后一定要释放。</p><h5 id="实现">实现</h5><p>有两种限制，所以对每层楼都需要两个信号量记为s1(4,true),s2(2,true)，当电梯需要开门的时候，如果是普通的电梯只需要获得s1即可，而只接人电梯则需要先获得s1再获得s2(顺序好像没关系)，关门的时候再释放相应信号量即可，信号量都放在了<strong>请求计数</strong>中。</p><h3 id="复杂度分析-3">复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/13/202304132246.png" alt="image-20230413172246586"></p><p>getDispatchGoal是求下一个目的地的部分，内部有挺多的循环嵌套和if-else判断。</p><h3 id="Bug分析-3">Bug分析</h3><p>三次测试都没问题，强测得分95.2392，不过用hhl同学的评测机总会是不是出现线程无法正常结束的情况，通过输出信息发现是有乘客被吃掉了，放入了电梯但是并没有去接他，最后也没有发现是哪出问题了。</p><h2 id="心得体会">心得体会</h2><ul><li><p>三次作业电梯运行、策略、输入以及请求队列部分原有的代码基本上都不会发生太大改变，主要的变化在于电梯增加维修的能力，调度器更换调度策略还有结束的判断等，不过只要大的框架定了后续的迭代也就比较简单了。可以发现的是后续迭代课程组对没有调度器的自由竞争并不是很友好，如果不在第二次作业进行重构的话，第三次作业需要改动的东西就更多了。不过架构的确定还是蛮看经验的，也不能说某一个架构就一定好，不过还是应该尽量满足<strong>solid</strong>原则。</p></li><li><p>性能方面，我还是为了简单和易于实现起见，牺牲了部分性能，调度采用自由竞争、随机分配和均匀分配，有的同学采用影子电梯(复制所有电梯状态，模拟判断请求的最优分配方式)，听说得分挺高的，不过本来电梯调度就没有全局最优，我认为首要的还是应该保证架构，有了比较好的架构，换一个调度器也不是很麻烦的事，就像荣文戈老师说的，分工好之后要是这个调度不行就换个程序员做调度器。</p></li><li><p>总的来说，相比于第一单元，这一单元感觉架构更加清晰，各个模块耦合度不高，功能也相对清晰，更有面向对象的感觉。不过这次作业还是留下了一点遗憾，就是第二三次作业的bug还是没找出来，这也让我感到多线程的艰难。</p></li></ul><h2 id="参考">参考</h2><p><a href="https://hyggge.github.io/2022/04/29/oo/oo-di-er-dan-yuan-zong-jie/">「BUAA-OO」第二单元:电梯调度 | Hyggge’s Blog</a></p><p><a href="https://www.cnblogs.com/saltyfishyjk/p/16218001.html#plantuml%E7%BB%98%E5%9B%BE">「BUAA OO Unit 2 HW8」第二单元总结 - 被水淹没的一条鱼</a></p><p><a href="https://blog.csdn.net/qq_41082953/article/details/120056344">HashMap遍历的时候使用map.remove会报错</a></p><p><a href="https://javastack.blog.csdn.net/article/details/129434123">为什么 HashMap 不能一边遍历一边删除？</a></p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> 电梯调度 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvim-配置</title>
      <link href="/posts/1ce0a0b5.html"/>
      <url>/posts/1ce0a0b5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在配置nvim插件的时候遇到了很多的问题，现在记录下来防止以后重复工作，整个配置放在了<a href="https://github.com/Makima777/nvim">Makima777/nvim (github.com)</a>,其中大部分是根据彭启阳同学在OS课程分享的配置更改的。</p><h2 id="1-nvim-treesitter"><a href="#1-nvim-treesitter" class="headerlink" title="1. nvim-treesitter"></a>1. nvim-treesitter</h2><p><a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter</a>是一款具有<strong>代码高亮</strong>，<strong>增量选择</strong>，<strong>代码格式化</strong>以及<strong>折叠代码块</strong>的功能，后面三个我暂时还没用上。</p><p>在安装语言解析器(parser)的时候，对于<code>yaml</code>和<code>html</code>两种语言的时候一直出现错误，报错信息大概是<code>Impossible to load parser for html: Failed to load parser</code>。</p><p>后面在<a href="https://github.com/nvim-treesitter/nvim-treesitter/issues/3587">issue</a>里面找到了相似的问题，原因就是这两种语言在解析器里会使用c++，需要c++的标准库，然后nvim自带的libstdc++-6.dll和gcc的冲突，解决方法就是改变编译器,<code>zig</code>或者<code>clang</code>都可以。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;nvim-treesitter.install&#x27;</span>).compilers = &#123;<span class="string">&quot;zig&quot;</span>, <span class="string">&quot;gcc&quot;</span>, <span class="string">&quot;clang&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-内置终端"><a href="#2-内置终端" class="headerlink" title="2. 内置终端"></a>2. 内置终端</h2><p>在Windows下nvim的内置终端选择的是cmd，用着很不舒服，可以通过以下命令将其改成powershell。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell = vim.fn.executable <span class="string">&quot;pwsh&quot;</span> == <span class="number">1</span> <span class="keyword">and</span> <span class="string">&quot;pwsh&quot;</span> <span class="keyword">or</span> <span class="string">&quot;powershell&quot;</span>,</span><br><span class="line">shellcmdflag = <span class="string">&quot;-NoLogo -NoProfile -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;&quot;</span>,</span><br><span class="line">shellredir = <span class="string">&quot;-RedirectStandardOutput %s -NoNewWindow -Wait&quot;</span>,</span><br><span class="line">shellpipe = <span class="string">&quot;2&gt;&amp;1 | Out-File -Encoding UTF8 %s; exit $LastExitCode&quot;</span>,</span><br><span class="line">shellquote = <span class="string">&quot;&quot;</span>,</span><br><span class="line">shellxquote = <span class="string">&quot;&quot;</span>,</span><br></pre></td></tr></table></figure><h2 id="3-nvim-tree"><a href="#3-nvim-tree" class="headerlink" title="3. nvim-tree"></a>3. nvim-tree</h2><p><a href="https://github.com/nvim-tree/nvim-tree.lua">nvim-tree</a>是一款文件管理的插件，可以显示git等信息。</p><p>但是在文件排序的时候默认会根据字典序排，如果遇到数字的话就会出现<code>1,10,2</code>这样的顺序，根据<a href="https://github.com/nvim-tree/nvim-tree.lua/discussions/1896">issue</a>配置就可以解决这个问题了。</p><h2 id="4-code-runner"><a href="#4-code-runner" class="headerlink" title="4. code_runner"></a>4. code_runner</h2><p><a href="https://github.com/CRAG666/code_runner.nvim">code_runner</a>是一款快速运行文件或者项目的插件，通过参数设置可以配置对应文件或者项目的运行命令。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filetype = &#123;</span><br><span class="line">    c = <span class="string">&#x27;cd %:p:h &amp;&amp; gcc -g -Wall -lm -std=c11 % -o .\\bin\\$fileNameWithoutExt &amp;&amp; .\\bin\\$fileNameWithoutExt&#x27;</span>,</span><br><span class="line">    cpp = <span class="string">&#x27;cd %:p:h &amp;&amp; g++ -g -O2 -Wall -lm -std=c++17 % -o .\\bin\\$fileNameWithoutExt &amp;&amp; .\\bin\\$fileNameWithoutExt&#x27;</span>,</span><br><span class="line">    lua = <span class="string">&#x27;lua&#x27;</span>,</span><br><span class="line">    python = <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    sh = <span class="string">&#x27;bash&#x27;</span>,</span><br><span class="line">    dosbatch = <span class="string">&#x27;cd $dir &amp;&amp; %&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我目前只需要单文件的运行，所以并不是很复杂，其中带<code>$</code>的参数都是code_runner的内置变量，<code>dir</code>代表打开文件的目录，<code>fileName</code>代表文件名，<code>file</code>代表文件路径，<code>fileNameWithoutExt</code>代表没有后缀的文件名。<code>%</code>等是vim的内置变量，详见<a href="https://vimdoc.sourceforge.net/htmldoc/cmdline.html#filename-modifiers">vim 文档</a>。需要注意的是如果不使用code_runner的内置变量那么命令最后会自己加上文件名。</p>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> nvim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-hexo</title>
      <link href="/posts/b68a7456.html"/>
      <url>/posts/b68a7456.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录Hexo博客搭建过程中的修改配置，主要基于<a href="https://github.com/fomalhaut1998/hexo-theme-Fomalhaut">Fomalhaut</a>大佬分享的配置进行修改。</p><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p><code>Front-matter</code> 是 markdown 文件最上方以<code>---</code>分隔的区域，用于指定个别档案的变数。</p><h3 id="Page-Front-matter-页面配置"><a href="#Page-Front-matter-页面配置" class="headerlink" title="Page Front-matter 页面配置"></a>Page Front-matter 页面配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>title</td><td style="text-align:center">[必需]页面标题</td></tr><tr><td>date</td><td style="text-align:center">[必需]页面创建时间</td></tr><tr><td>updated</td><td style="text-align:center">[可选]页面更新日期</td></tr><tr><td>type</td><td style="text-align:center">[必需]标签、分类以及友情链接三个页面需要配置</td></tr><tr><td>comments</td><td style="text-align:center">[可选]显示页面评论模块(默认 true)</td></tr><tr><td>description</td><td style="text-align:center">[可选]页面描述</td></tr><tr><td>keywords</td><td style="text-align:center">[可选]页面关键词</td></tr><tr><td>top_img</td><td style="text-align:center">[可选]页面顶部图片</td></tr><tr><td>mathjax</td><td style="text-align:center">[可选]显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td style="text-align:center">[可选]显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td style="text-align:center">[可选]显示侧边栏(默认 true)</td></tr><tr><td>aplayer</td><td style="text-align:center">[可选]在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td style="text-align:center">[可选]配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置,我设置为 true)</td></tr></tbody></table></div><h3 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">aside:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>title</td><td style="text-align:center">[必需]文章标题</td></tr><tr><td>date</td><td style="text-align:center">[必需]文章创建时间</td></tr><tr><td>updated</td><td style="text-align:center">[可选]文章更新日期</td></tr><tr><td>tags</td><td style="text-align:center">[可选]文章标签</td></tr><tr><td>categories</td><td style="text-align:center">[可选]文章分类</td></tr><tr><td>keywords</td><td style="text-align:center">[可选]文章关键词</td></tr><tr><td>description</td><td style="text-align:center">[可选]文章描述</td></tr><tr><td>top_img</td><td style="text-align:center">[可选]文章顶部图片</td></tr><tr><td>comments</td><td style="text-align:center">[可选]显示文章评论模块(默认 true)</td></tr><tr><td>cover</td><td style="text-align:center">[可选]文章缩略图</td></tr><tr><td>toc</td><td style="text-align:center">[可选]显示文章TOC(默认为设置中toc的enable配置,我设置为 true)</td></tr><tr><td>toc_number</td><td style="text-align:center">[可选]显示toc_number(默认为设置中toc的number配置,我设置为 true)</td></tr><tr><td>toc_style_simple</td><td style="text-align:center">[可选]显示 toc 简洁模式</td></tr><tr><td>copyright</td><td style="text-align:center">[可选]显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td style="text-align:center">[可选]文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td style="text-align:center">[可选]文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td style="text-align:center">[可选]文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td style="text-align:center">[可选]文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td style="text-align:center">[可选]显示mathjax(当设置mathjax的per_page: false时，才需要配置,默认 false)</td></tr><tr><td>katex</td><td style="text-align:center">[可选]显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td style="text-align:center">[可选]显示侧边栏(默认 true)</td></tr><tr><td>aplayer</td><td style="text-align:center">[可选]在需要的文章加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td style="text-align:center">[可选]配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table></div><h2 id="图床设置"><a href="#图床设置" class="headerlink" title="图床设置"></a>图床设置</h2><h3 id="Github-PicGo-typora"><a href="#Github-PicGo-typora" class="headerlink" title="Github + PicGo + typora"></a>Github + PicGo + typora</h3><p>在github中新建一个仓库作为图床，使用typora插入图片的时候可以通过<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>上传到github中。</p><h3 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h3><p>具体配置部分，勾选需要显示的图床(默认全部显示)<img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304123035.png" alt="image-20230412113035788"></p><p>在图床设置内选中相应的图床进行设置</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122929.png" alt="image-20230412112929180"></p><p>其中图床配置名随意，仓库名按照 github用户名/创建的仓库名 的格式填入即可，分支名输入仓库默认分支即可，Token需要创建，在github页面点击右上角头像<code>Settings-&gt;Developer settings-&gt;personal access tokens-&gt;token(classic)</code>，然后点击<code>Generate new token(classic)</code></p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122840.png" alt="image-20230412112840083"></p><p>Note随意，Expiration有效期选择No expiration(有效期过了之后似乎是需要续期的，嫌麻烦的话直接不设就行），需要注意的是生成之后token只会显示一次，需要复制下来填入上面显示的空里面。</p><p>储存路径就是在图片在仓库中的储存位置，例如img/就会在存在img文件夹内。</p><p>自定义域名我暂时还没用到，如果访问github很慢的话可能需要设置。</p><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304122705.png" alt="image-20230412112705624"></p><p>在<code>偏好设置-&gt;图像</code>中如上图设置即可，优先使用相对路径需要取消勾选，PicGo路径选择自己的安装路径即可，通过验证图片上传选项可以测试自己是否配置成功。</p><h3 id="PicGo插件"><a href="#PicGo插件" class="headerlink" title="PicGo插件"></a>PicGo插件</h3><p>PicGo提供了很多优秀的插件，可以在<code>插件设置</code>中进行搜索安装。</p><h4 id="github-plus"><a href="#github-plus" class="headerlink" title="github-plus"></a>github-plus</h4><p>在使用的时候会发现，光是在PicGo的相册中删除图片，github中储存的图片并不会消失，于是可以安装<a href="https://github.com/zWingz/picgo-plugin-github-plus">github-plus</a>插件，对操作进行同步，同时能够把远端的图片pull到相册中。</p><p>安装之后在PicGo设置中勾选githubPlus，然后设置和之前一样即可，token如果忘记了可以去设置中打开<code>配置文件</code>,里面记录了token复制即可(<del>虽然不知道这样真的有安全性吗，还有就是这个插件的token不会隐藏</del>)，接着需要将这个图床设置为默认图床，否则上传还是之前的github设置，即使取消勾选了。</p><p>这个插件还有一个比较好的地方就是他还支持gitee，只需要在origin那一个设置中选择即可。</p><h4 id="super-prefix"><a href="#super-prefix" class="headerlink" title="super-prefix"></a>super-prefix</h4><p>这一款<a href="https://github.com/gclove/picgo-plugin-super-prefix">插件</a>是用于图片命名的，安装之后可以进行设置</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304123332.png" alt="image-20230412113332495"></p><p>文件名个性前缀就是设置图片的储存路径，例如图片名为202304123332，那么就会被储存在2023/04/12这个文件夹下，相当于按日期分类了，使用这个需要关掉PicGo的时间戳重命名。</p><p>目前我还没试过除了日期还能不能用其他的命名。</p><h2 id="参考以及好看的主题收录"><a href="#参考以及好看的主题收录" class="headerlink" title="参考以及好看的主题收录"></a>参考以及好看的主题收录</h2><p><a href="https://www.fomal.cc/">Fomalhaut🥝</a></p><p><a href="https://github.com/hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next">hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next</a></p><p><a href="https://tzy1997.com/">唐志远の博客 (tzy1997.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BUAA OO Unit 1 HW4] 第一单元总结</title>
      <link href="/posts/a1dc732f.html"/>
      <url>/posts/a1dc732f.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一单元的主题是表达式括号展开化简，初步体会面向对象的思想，学习使用类管理数据，分工协作的行为设计等。该单元一共有三次作业层层递进，逐步实现括号嵌套，自定义函数，三角函数和求导等功能。</p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>第一次作业为多变量表达式括号展开，运算分为加、减、乘和乘方四种，括号深度至多为一层，UML类图如下图所示</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120229.png" alt="image-20230318195545580"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>通过形式化表达可知表达式遵循<code>expr-&gt;term-&gt;factor</code>的结构，通过递归下降算法可以将这些部分给解析出来，和正则表达式相比支持迭代。</p><p>不难发现 $expr = \sum coe<em>x^{expX}</em>y^{expY}<em>z^{expZ}$,其实无论是factor或者term都可以表示成上述式子，于是为了可以将其统一成<code>Operator</code>类进行计算。同时为了便于同类项的合并，将 $x^{expX}</em>y^{expY}*z^{expZ}$ 封装成<code>Unit</code>类，<code>Operator</code>采用HashMap进行储存，其中key为<code>Unit</code>，value为<code>coe</code>。</p><p>本次作业的因子<code>Pow</code>和<code>Number</code>都继承<code>Operator</code>类，<code>Parse</code>类中方法的返回值都为<code>Operator</code>，于是对于<code>Operator</code>来说只需要实现加法和乘法即可，同类项合并以及括号展开都是在这个过程中实现的。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>本次作业部分方法复杂度如下，其余方法复杂度较低</p><ul><li>CogC:认知复杂度，代码被阅读和理解的复杂程度</li><li>ev(G):衡量程序非结构化程度</li><li>iv(G):衡量模块判定结构即模块和其他模块的调用关系，模块设计复杂度高意味着模块耦合度高</li><li>v(G):衡量模块判定结构复杂度，数量上表现为独立路径的条数(与循环以及条件语句有关)，圈复杂度大会导致难以测试和维护</li></ul><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120452.png" alt="image-20230316201823884"></p><p>总的复杂度不算太高，对于<code>Operator</code>的<code>toString</code>方法因为需要选出一个正项先输出，就导致需要额外一次对HashMap的遍历，其实也不是很有必要。</p><h3 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>中测出现以下错误</p><ul><li>解析数字因子的时候忘记还有符号了</li><li>在解析指数之后没有进行<code>lexer.next()</code>的操作</li><li><code>isConstant</code>方法将其中的 $expZ$ 写成 $expX$ 了，导致会将 $z^y$ 判断为不含未知数</li></ul><p>强测和互测没有出现bug</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>HashMap以类作为键值通常判断相等是基于两个类的地址来说，也就是是否是同一个实例，所以想要通过内部元素判断相等就得重写hashcode和equal函数，判断过程为如果hashcode不等为不等，否则通过equal函数判断，所以hashcode作为基础判断只需要保证构造的函数使得相等对象hashcode相同即可，想要简单的话也可以返回统一值跳过这一判断。</li><li>预处理将空白符去掉，<code>**</code>变成<code>^</code>方便判断</li><li>对于连续的+-号并未提前处理，对于项之前的符号用sign传入<code>parseTerm</code>方法中，对于数字则是在<code>parseFactor</code>中进行处理</li><li>优化：<ol><li>$x<em>*2$-&gt;$x</em>x$</li><li>将正的项先输出</li><li>对于系数为$\pm1$且含有未知数因子的项不输出1</li></ol></li></ul><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><p>第二次作业支持括号嵌套，新增三角函数因子和自定义函数因子，UML类图如下图所示</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120459.png" alt="image-20230318200106301"></p><h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p>对于三角函数的处理，<code>Unit</code>需要表示为 $x^{expX}<em>y^{expY}</em>z^{expZ}*\prod(sin(expr_i))\prod(cos(expr_i))$ ，为了便于输出与合并同样采用HashMap储存三角函数，key值为expr即<code>Operator</code>类，value值为该三角函数的指数部分，新增继承<code>Operator</code>的<code>Sin</code>和<code>Cos</code>类进行构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unit.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Operator, Integer&gt; sinMap;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Operator, Integer&gt; cosMap;</span><br></pre></td></tr></table></figure><p>对于自定义函数的处理，新增<code>Definer</code>类处理自定义函数的定义和调用，所有成员以及方法都是静态的，直接采用类名调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,String&gt; funcMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt; paraMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">funcPattern</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;funcName&gt;[fgh])\\((?&lt;para&gt;.*)\\)=(?&lt;expr&gt;.*)&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">paraPattern</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;para&gt;[xyz]),?&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addFunc</span><span class="params">(String input)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">callFunc</span><span class="params">(String funcName,ArrayList&lt;Operator&gt; actualPara)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>addFunc</code>内部采用正则表达式分割自定义函数各部分。<code>callFunc</code>调用的时候传入的实参是<code>Operator</code>类的，也可以调用它的<code>toString</code>方法传入String类型的数组,具体过程是按字符遍历函数定义式，如果是参数就用对应位置的实参替换(不是在原String替换，而是新建一个StringBuilder)。</p><p>同时新增<code>Function</code>类储存调用之后得到的表达式，同时可以将此表达式解析成<code>Operator</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String expr;</span><br><span class="line"><span class="keyword">public</span> Operator <span class="title function_">expandExpr</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在<code>Parse</code>中新增<code>parseFunction</code>方法，内部使用<code>parseFactor</code>读取实参列表，接着使用<code>callFunc</code>得到新的表达式，再返回<code>expandExpr</code>即可。</p><p>这次调整了一下<code>Parse</code>内部解析因子的方法，将对数字、未知数、三角函数和指数等的解析用方法封装了起来，指数的处理在需要的方法内进行，使得未知数以及三角函数的指数不用通过乘法实现而是直接赋值，总体来说可读性和可维护性提高了。</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120513.png" alt="image-20230317103249850"></p><p>部分方法复杂度如上，<code>Unit</code>中的<code>equals</code>复杂度高是因为采用涉及两个HashMap的相等判断，先用if判断了size其次使用for循环判断元素是否存在映射，主要是sin和cos虽然结构类似但是由于采用两个容器储存，导致不能进行统一处理，结果出现了很多的重复性工作，这一缺点在输出等地方均存在。<code>Operator</code>的<code>equals</code>也是由于HashMap的相等判断。</p><h3 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>中测</p><ul><li>就像上面说的一样，因为Cos和Sin很多类似的操作，所以复制代码结果导致一些地方没有修改到（<del>复制是坏文明</del></li><li>$cos(0)=0$</li></ul><p>强测和互测</p><ul><li>$sin(0)^0=0$</li><li>比较表达式相等的时候忘记比较系数了，导致$sin(x)+sin(2x)=2sin(x)$</li></ul><p>互测过程中有一个同学没有处理自定义函数中的空白字符(<del>帮我挽回了一点分数</del></p><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><ul><li>对于函数实参的代入不能直接<code>replaceAll</code>，不然可能将已替换实参中的未知数替换掉，研讨课某些同学提出将<code>xyz</code>换成<code>pqr</code>等没出现的字符(<del>可行不过没有可拓展性</del>)，还有使用java中的<code>MessageFormat</code>类替换的。</li><li>传入实参需要在左右两侧加括号。</li></ul><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><p>第三次作业新增求导因子，函数定义时可以调用已有函数，函数定义中的求导因子先求导再代入实参,UML类图如下</p><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120518.png" alt="image-20230318204703578"></p><h3 id="架构-2"><a href="#架构-2" class="headerlink" title="架构"></a>架构</h3><p>这次主要就是在<code>Operator</code>和<code>Unit</code>分别加入求导的方法,通过乘法法则和链式法则等返回新的表达式,需要注意的是<code>Unit</code>采用乘法法则需要深拷贝。</p><p>其次函数在定义的时候先进行解析操作去掉求导因子，于是将解析字符串的操作封装在<code>Definer</code>方法中(<del><code>Function</code>显得更没必要了</del>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Operator <span class="title function_">simplifyExpr</span><span class="params">(String expr)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Lexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lexer</span>(expr);</span><br><span class="line">    <span class="type">Parser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parser</span>(lexer);</span><br><span class="line">    <span class="keyword">return</span> parser.parseExpr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="https://raw.githubusercontent.com/makima777/pic_bed/master/img/2023/04/12/202304120524.png" alt="image-20230317112423675"></p><p>部分方法复杂度如上，自己比较习惯将一些模块化的部分封装成方法进行调用，所以复杂度看上去还好，不然的话某些方法会很臃肿复杂度可能也会很高，不过也会导致方法很多的问题。</p><h3 id="tips-2"><a href="#tips-2" class="headerlink" title="tips"></a>tips</h3><ul><li>第二次作业中sin输出内部因子无脑加了层括号，在这一次判断了是否是单因子，减少括号输出，主要有数字，幂函数，三角函数这三种情况，不过由于 $x^2$ 会输出为$x*x$，所以需要特判一下。</li></ul><h3 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>中测</p><ul><li>主要bug就出在上面所说的优化判断，细节没有考虑好</li></ul><p>强测和互测没有bug。</p><h2 id="反思与体会"><a href="#反思与体会" class="headerlink" title="反思与体会"></a>反思与体会</h2><ul><li>还是比较面向过程，主打的就是<strong>everything is Operator</strong>，没有将各模块解耦合，都集中在<code>Operator</code>和<code>Unit</code>两个部分，理想的架构应该是先解析出式子，再实现括号展开以及化简，用老师的话来说就是可以将每部分的工作交给不同的程序员来做。</li><li><code>Number</code>等单因子虽然继承了<code>Operator</code>但是实际上没有什么自己的feature，只是为了方便构造或者理解，有些鸡肋。</li><li><code>Unit</code>中指数的部分是用三个数分别储存的，对于后面可能的迭代开发并不是很有利，而且在某些方法中需要进行一个一个判断，应该使用HashMap储存会更加合理。</li><li>作业中对三角函数做过多的优化，只是在构造的时候对sin(0)和cos(0)进行了简单的判断，不过也多亏了是边构造边化简的形式，当然也是架构的问题导致过程中不太能做更多的三角优化，除非最后再进行一次化简。</li><li>三角函数没做统一处理，导致很多重复性的工作，后面再出现其余的三角函数的话，就需要继续同样的操作，应该合并成一个类在里面存有三角函数名。</li><li>这次就只有没测试的第二次作业出问题了(<del>虽然第一次和第三次都是用的大佬的评测机</del>),深深体会到了评测的必要性。</li><li>OO的讨论区有很多大佬分享自己的架构经验以及评测等等，没有思路的时候可以多看看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> JAVA </tag>
            
            <tag> 表达式化简 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
